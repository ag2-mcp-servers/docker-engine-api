# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:35:26+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Header, Query, Request
from pydantic import constr

from models import (
    AuthConfig,
    AuthPostResponse,
    BuildPrunePostResponse,
    Config,
    ConfigsCreatePostRequest,
    ConfigsCreatePostResponse,
    ConfigsGetResponse,
    ConfigSpec,
    ContainerConfig,
    ContainersCreatePostRequest,
    ContainersCreatePostResponse,
    ContainersIdArchiveGetResponse,
    ContainersIdArchiveHeadResponse,
    ContainersIdChangesGetResponse,
    ContainersIdExecPostRequest,
    ContainersIdJsonGetResponse,
    ContainersIdStatsGetResponse,
    ContainersIdTopGetResponse,
    ContainersIdUpdatePostRequest,
    ContainersIdUpdatePostResponse,
    ContainersIdWaitPostResponse,
    ContainersPrunePostResponse,
    ContainerSummary,
    ContentType,
    DistributionNameJsonGetResponse,
    ErrorResponse,
    EventsGetResponse,
    ExecIdJsonGetResponse,
    ExecIdStartPostRequest,
    IdResponse,
    Image,
    ImagesJsonGetResponse,
    ImagesNameDeleteResponse,
    ImagesNameHistoryGetResponse,
    ImagesPrunePostResponse,
    ImagesSearchGetResponse,
    Names,
    Network,
    NetworksCreatePostRequest,
    NetworksCreatePostResponse,
    NetworksGetResponse,
    NetworksIdDisconnectPostRequest,
    NetworksPrunePostResponse,
    Node,
    NodesGetResponse,
    NodeSpec,
    Plugin1,
    PluginsGetResponse,
    PluginsNameSetPostRequest,
    PluginsNameUpgradePostRequest,
    PluginsPrivilegesGetResponse,
    PluginsPullPostRequest,
    Secret,
    SecretsCreatePostRequest,
    SecretsCreatePostResponse,
    SecretsGetResponse,
    SecretSpec,
    Service,
    ServicesCreatePostRequest,
    ServicesCreatePostResponse,
    ServicesGetResponse,
    ServicesIdUpdatePostRequest,
    ServiceUpdateResponse,
    Swarm,
    SwarmInitPostRequest,
    SwarmJoinPostRequest,
    SwarmSpec,
    SwarmUnlockkeyGetResponse,
    SwarmUnlockPostRequest,
    SystemDfGetResponse,
    SystemInfo,
    Task,
    TasksGetResponse,
    VersionGetResponse,
    Volume,
    VolumesCreatePostRequest,
    VolumesGetResponse,
    VolumesPrunePostResponse,
)

app = MCPProxy(
    description='The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.\n\nMost of the client\'s commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.\n\n# Errors\n\nThe API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:\n\n```\n{\n  "message": "page not found"\n}\n```\n\n# Versioning\n\nThe API is usually changed in each release of Docker, so API calls are versioned to ensure that clients don\'t break.\n\nFor Docker Engine 17.09, the API version is 1.32. To lock to this version, you prefix the URL with `/v1.32`. For example, calling `/info` is the same as calling `/v1.32/info`.\n\nEngine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.\n\nIn previous versions of Docker, it was possible to access the API without providing a version. This behaviour is now deprecated will be removed in a future version of Docker.\n\nThe API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer Docker daemons.\n\nThis documentation is for version 1.33 of the API. Use this table to find documentation for previous versions of the API:\n\nDocker version  | API version | Changes\n----------------|-------------|---------\n17.09.x | [1.31](https://docs.docker.com/engine/api/v1.32/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-32-api-changes)\n17.07.x | [1.31](https://docs.docker.com/engine/api/v1.31/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-31-api-changes)\n17.06.x | [1.30](https://docs.docker.com/engine/api/v1.30/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-30-api-changes)\n17.05.x | [1.29](https://docs.docker.com/engine/api/v1.29/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-29-api-changes)\n17.04.x | [1.28](https://docs.docker.com/engine/api/v1.28/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-28-api-changes)\n17.03.1 | [1.27](https://docs.docker.com/engine/api/v1.27/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-27-api-changes)\n1.13.1 & 17.03.0 | [1.26](https://docs.docker.com/engine/api/v1.26/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-26-api-changes)\n1.13.0 | [1.25](https://docs.docker.com/engine/api/v1.25/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-25-api-changes)\n1.12.x | [1.24](https://docs.docker.com/engine/api/v1.24/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-24-api-changes)\n1.11.x | [1.23](https://docs.docker.com/engine/api/v1.23/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-23-api-changes)\n1.10.x | [1.22](https://docs.docker.com/engine/api/v1.22/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-22-api-changes)\n1.9.x | [1.21](https://docs.docker.com/engine/api/v1.21/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-21-api-changes)\n1.8.x | [1.20](https://docs.docker.com/engine/api/v1.20/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-20-api-changes)\n1.7.x | [1.19](https://docs.docker.com/engine/api/v1.19/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-19-api-changes)\n1.6.x | [1.18](https://docs.docker.com/engine/api/v1.18/) | [API changes](https://docs.docker.com/engine/api/version-history/#v1-18-api-changes)\n\n# Authentication\n\nAuthentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a Base64 encoded (JSON) string with the following structure:\n\n```\n{\n  "username": "string",\n  "password": "string",\n  "email": "string",\n  "serveraddress": "string"\n}\n```\n\nThe `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.\n\nIf you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:\n\n```\n{\n  "identitytoken": "9cbaf023786cd7..."\n}\n```\n',
    title='Docker Engine API',
    version='1.33',
    servers=[
        {'url': '/v1.33'},
        {
            'url': 'https://docker.com/{version}',
            'variables': {'version': {'default': '1.33'}},
        },
    ],
)


@app.get(
    '/_ping',
    description=""" This is a dummy endpoint you can use to test if the server is accessible. """,
    tags=['system_health_check', 'network_operations'],
)
def system_ping():
    """
    Ping
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth',
    description=""" Validate credentials for a registry and, if available, get an identity token for accessing the registry without password. """,
    tags=['system_health_check', 'config_management'],
)
def system_auth(body: AuthConfig = None):
    """
    Check auth configuration
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/build',
    description=""" Build an image from a tar archive with a `Dockerfile` in it.

The `Dockerfile` specifies how the image is built from the tar archive. It is typically in the archive's root, but can be at a different path or have a different name by specifying the `dockerfile` parameter. [See the `Dockerfile` reference for more information](https://docs.docker.com/engine/reference/builder/).

The Docker daemon performs a preliminary validation of the `Dockerfile` before starting the build, and returns an error if the syntax is incorrect. After that, each instruction is run one-by-one until the ID of the new image is output.

The build is canceled if the client drops the connection by quitting or being killed.
 """,
    tags=['image_management'],
)
def image_build(
    dockerfile: Optional[str] = 'Dockerfile',
    t: Optional[str] = None,
    extrahosts: Optional[str] = None,
    remote: Optional[str] = None,
    q: Optional[bool] = False,
    nocache: Optional[bool] = False,
    cachefrom: Optional[str] = None,
    pull: Optional[str] = None,
    rm: Optional[bool] = True,
    forcerm: Optional[bool] = False,
    memory: Optional[int] = None,
    memswap: Optional[int] = None,
    cpushares: Optional[int] = None,
    cpusetcpus: Optional[str] = None,
    cpuperiod: Optional[int] = None,
    cpuquota: Optional[int] = None,
    buildargs: Optional[int] = None,
    shmsize: Optional[int] = None,
    squash: Optional[bool] = None,
    labels: Optional[str] = None,
    networkmode: Optional[str] = None,
    content_type: Optional[ContentType] = Header(
        'application/x-tar', alias='Content-type'
    ),
    x__registry__config: Optional[str] = Header(None, alias='X-Registry-Config'),
    request: Request = ...,
):
    """
    Build an image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/build/prune', tags=['system_health_check', 'config_management'])
def build_prune():
    """
    Delete builder cache
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/commit', tags=['image_management', 'container_management'])
def image_commit(
    container: Optional[str] = None,
    repo: Optional[str] = None,
    tag: Optional[str] = None,
    comment: Optional[str] = None,
    author: Optional[str] = None,
    pause: Optional[bool] = True,
    changes: Optional[str] = None,
    body: ContainerConfig = None,
):
    """
    Create a new image from a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/configs', tags=['config_management', 'system_information'])
def config_list(filters: Optional[str] = None):
    """
    List configs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/configs/create', tags=['config_management'])
def config_create(body: ConfigsCreatePostRequest = None):
    """
    Create a config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/configs/{id}', tags=['config_management'])
def config_delete(id: str):
    """
    Delete a config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/configs/{id}', tags=['config_management', 'system_health_check'])
def config_inspect(id: str):
    """
    Inspect a config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/configs/{id}/update', tags=['config_management'])
def config_update(id: str, version: int = ..., body: ConfigSpec = None):
    """
    Update a Config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/containers/create', tags=['container_management'])
def container_create(
    name: Optional[constr(pattern=r'/?[a-zA-Z0-9_-]+')] = None,
    body: ContainersCreatePostRequest = ...,
):
    """
    Create a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/containers/json',
    description=""" Returns a list of containers. For details on the format, see [the inspect endpoint](#operation/ContainerInspect).

Note that it uses a different, smaller representation of a container than inspecting a single container. For example,
the list of linked containers is not propagated .
 """,
    tags=['container_management', 'system_monitoring'],
)
def container_list(
    all: Optional[bool] = False,
    limit: Optional[int] = None,
    size: Optional[bool] = False,
    filters: Optional[str] = None,
):
    """
    List containers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/containers/prune', tags=['container_management'])
def container_prune(filters: Optional[str] = None):
    """
    Delete stopped containers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/containers/{id}', tags=['container_management'])
def container_delete(
    id: str,
    v: Optional[bool] = False,
    force: Optional[bool] = False,
    link: Optional[bool] = False,
):
    """
    Remove a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/containers/{id}/archive',
    description=""" Get a tar archive of a resource in the filesystem of container id. """,
    tags=['container_management', 'container_interaction'],
)
def container_archive(id: str, path: str = ...):
    """
    Get an archive of a filesystem resource in a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.head(
    '/containers/{id}/archive',
    description=""" A response header `X-Docker-Container-Path-Stat` is return containing a base64 - encoded JSON object with some filesystem header information about the path. """,
    tags=['container_management', 'container_interaction'],
)
def container_archive_info(id: str, path: str = ...):
    """
    Get information about files in a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/containers/{id}/archive',
    description=""" Upload a tar archive to be extracted to a path in the filesystem of container id. """,
    tags=['container_interaction', 'volume_management'],
)
def put_container_archive(
    id: str,
    path: str = ...,
    no_overwrite_dir_non_dir: Optional[str] = Query(None, alias='noOverwriteDirNonDir'),
    request: Request = ...,
):
    """
    Extract an archive of files or folders to a directory in a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/containers/{id}/attach',
    description=""" Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.

Either the `stream` or `logs` parameter must be `true` for this endpoint to do anything.

See [the documentation for the `docker attach` command](https://docs.docker.com/engine/reference/commandline/attach/) for more details.

### Hijacking

This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`, and `stderr` on the same socket.

This is the response from the daemon for an attach request:

```
HTTP/1.1 200 OK
Content-Type: application/vnd.docker.raw-stream

[STREAM]
```

After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.

To hint potential proxies about connection hijacking, the Docker client can also optionally send connection upgrade headers.

For example, the client sends this request to upgrade the connection:

```
POST /containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1
Upgrade: tcp
Connection: Upgrade
```

The Docker daemon will respond with a `101 UPGRADED` response, and will similarly follow with the raw stream:

```
HTTP/1.1 101 UPGRADED
Content-Type: application/vnd.docker.raw-stream
Connection: Upgrade
Upgrade: tcp

[STREAM]
```

### Stream format

When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate), the stream over the hijacked connected is multiplexed to separate out `stdout` and `stderr`. The stream consists of a series of frames, each containing a header and a payload.

The header contains the information which the stream writes (`stdout` or `stderr`). It also contains the size of the associated frame encoded in the last four bytes (`uint32`).

It is encoded on the first eight bytes like this:

```go
header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
```

`STREAM_TYPE` can be:

- 0: `stdin` (is written on `stdout`)
- 1: `stdout`
- 2: `stderr`

`SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size encoded as big endian.

Following the header is the payload, which is the specified number of bytes of `STREAM_TYPE`.

The simplest way to implement this protocol is the following:

1. Read 8 bytes.
2. Choose `stdout` or `stderr` depending on the first byte.
3. Extract the frame size from the last four bytes.
4. Read the extracted size and output it on the correct output.
5. Goto 1.

### Stream format when using a TTY

When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate), the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client's `stdin`.
 """,
    tags=['container_management', 'container_interaction'],
)
def container_attach(
    id: str,
    detach_keys: Optional[str] = Query(None, alias='detachKeys'),
    logs: Optional[bool] = False,
    stream: Optional[bool] = False,
    stdin: Optional[bool] = False,
    stdout: Optional[bool] = False,
    stderr: Optional[bool] = False,
):
    """
    Attach to a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/containers/{id}/attach/ws', tags=['container_management', 'container_interaction']
)
def container_attach_websocket(
    id: str,
    detach_keys: Optional[str] = Query(None, alias='detachKeys'),
    logs: Optional[bool] = False,
    stream: Optional[bool] = False,
    stdin: Optional[bool] = False,
    stdout: Optional[bool] = False,
    stderr: Optional[bool] = False,
):
    """
    Attach to a container via a websocket
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/containers/{id}/changes',
    description=""" Returns which files in a container's filesystem have been added, deleted,
or modified. The `Kind` of modification can be one of:

- `0`: Modified
- `1`: Added
- `2`: Deleted
 """,
    tags=['container_interaction', 'container_management'],
)
def container_changes(id: str):
    """
    Get changes on a container’s filesystem
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/containers/{id}/exec',
    description=""" Run a command inside a running container. """,
    tags=['exec_instance_management', 'container_interaction'],
)
def container_exec(id: str, body: ContainersIdExecPostRequest = ...):
    """
    Create an exec instance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/containers/{id}/export',
    description=""" Export the contents of a container as a tarball. """,
    tags=['container_management', 'image_management'],
)
def container_export(id: str):
    """
    Export a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/containers/{id}/json',
    description=""" Return low-level information about a container. """,
    tags=['container_management', 'container_interaction'],
)
def container_inspect(id: str, size: Optional[bool] = False):
    """
    Inspect a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/containers/{id}/kill',
    description=""" Send a POSIX signal to a container, defaulting to killing to the container. """,
    tags=['container_management', 'container_interaction'],
)
def container_kill(id: str, signal: Optional[str] = 'SIGKILL'):
    """
    Kill a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/containers/{id}/logs',
    description=""" Get `stdout` and `stderr` logs from a container.

Note: This endpoint works only for containers with the `json-file` or `journald` logging driver.
 """,
    tags=['container_management', 'container_interaction', 'service_management'],
)
def container_logs(
    id: str,
    follow: Optional[bool] = False,
    stdout: Optional[bool] = False,
    stderr: Optional[bool] = False,
    since: Optional[int] = 0,
    timestamps: Optional[bool] = False,
    tail: Optional[str] = 'all',
):
    """
    Get container logs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/containers/{id}/pause',
    description=""" Use the cgroups freezer to suspend all processes in a container.

Traditionally, when suspending a process the `SIGSTOP` signal is used, which is observable by the process being suspended. With the cgroups freezer the process is unaware, and unable to capture, that it is being suspended, and subsequently resumed.
 """,
    tags=['container_management'],
)
def container_pause(id: str):
    """
    Pause a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/containers/{id}/rename', tags=['container_management'])
def container_rename(id: str, name: str = ...):
    """
    Rename a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/containers/{id}/resize',
    description=""" Resize the TTY for a container. You must restart the container for the resize to take effect. """,
    tags=['exec_instance_management', 'container_management'],
)
def container_resize(id: str, h: Optional[int] = None, w: Optional[int] = None):
    """
    Resize a container TTY
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/containers/{id}/restart', tags=['container_management'])
def container_restart(id: str, t: Optional[int] = None):
    """
    Restart a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/containers/{id}/start', tags=['container_management'])
def container_start(
    id: str, detach_keys: Optional[str] = Query(None, alias='detachKeys')
):
    """
    Start a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/containers/{id}/stats',
    description=""" This endpoint returns a live stream of a container’s resource usage
statistics.

The `precpu_stats` is the CPU statistic of last read, which is used
for calculating the CPU usage percentage. It is not the same as the
`cpu_stats` field.

If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is
nil then for compatibility with older daemons the length of the
corresponding `cpu_usage.percpu_usage` array should be used.
 """,
    tags=['system_monitoring', 'container_management'],
)
def container_stats(id: str, stream: Optional[bool] = True):
    """
    Get container stats based on resource usage
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/containers/{id}/stop', tags=['container_management'])
def container_stop(id: str, t: Optional[int] = None):
    """
    Stop a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/containers/{id}/top',
    description=""" On Unix systems, this is done by running the `ps` command. This endpoint is not supported on Windows. """,
    tags=['container_management', 'container_interaction'],
)
def container_top(id: str, ps_args: Optional[str] = '-ef'):
    """
    List processes running inside a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/containers/{id}/unpause',
    description=""" Resume a container which has been paused. """,
    tags=['container_management', 'container_interaction'],
)
def container_unpause(id: str):
    """
    Unpause a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/containers/{id}/update',
    description=""" Change various configuration options of a container without having to recreate it. """,
    tags=['container_management'],
)
def container_update(id: str, body: ContainersIdUpdatePostRequest = ...):
    """
    Update a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/containers/{id}/wait',
    description=""" Block until a container stops, then returns the exit code. """,
    tags=['container_management', 'system_monitoring'],
)
def container_wait(id: str, condition: Optional[str] = 'not-running'):
    """
    Wait for a container
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/distribution/{name}/json',
    description=""" Return image digest and platform information by contacting the registry. """,
    tags=['image_management', 'system_information'],
)
def distribution_inspect(name: str):
    """
    Get image information from the registry
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/events',
    description=""" Stream real-time events from the server.

Various objects within Docker report events when something happens to them.

Containers report these events: `attach`, `commit`, `copy`, `create`, `destroy`, `detach`, `die`, `exec_create`, `exec_detach`, `exec_start`, `export`, `health_status`, `kill`, `oom`, `pause`, `rename`, `resize`, `restart`, `start`, `stop`, `top`, `unpause`, and `update`

Images report these events: `delete`, `import`, `load`, `pull`, `push`, `save`, `tag`, and `untag`

Volumes report these events: `create`, `mount`, `unmount`, and `destroy`

Networks report these events: `create`, `connect`, `disconnect`, `destroy`, `update`, and `remove`

The Docker daemon reports these events: `reload`

Services report these events: `create`, `update`, and `remove`

Nodes report these events: `create`, `update`, and `remove`

Secrets report these events: `create`, `update`, and `remove`

Configs report these events: `create`, `update`, and `remove`
 """,
    tags=['system_monitoring'],
)
def system_events(
    since: Optional[str] = None,
    until: Optional[str] = None,
    filters: Optional[str] = None,
):
    """
    Monitor events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/exec/{id}/json',
    description=""" Return low-level information about an exec instance. """,
    tags=['exec_instance_management', 'container_management'],
)
def exec_inspect(id: str):
    """
    Inspect an exec instance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/exec/{id}/resize',
    description=""" Resize the TTY session used by an exec instance. This endpoint only works if `tty` was specified as part of creating and starting the exec instance. """,
    tags=['exec_instance_management'],
)
def exec_resize(id: str, h: Optional[int] = None, w: Optional[int] = None):
    """
    Resize an exec instance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/exec/{id}/start',
    description=""" Starts a previously set up exec instance. If detach is true, this endpoint returns immediately after starting the command. Otherwise, it sets up an interactive session with the command. """,
    tags=['exec_instance_management', 'container_management'],
)
def exec_start(id: str, body: ExecIdStartPostRequest = None):
    """
    Start an exec instance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/images/create',
    description=""" Create an image by either pulling it from a registry or importing it. """,
    tags=['image_management'],
)
def image_create(
    from_image: Optional[str] = Query(None, alias='fromImage'),
    from_src: Optional[str] = Query(None, alias='fromSrc'),
    repo: Optional[str] = None,
    tag: Optional[str] = None,
    x__registry__auth: Optional[str] = Header(None, alias='X-Registry-Auth'),
    request: Request = ...,
):
    """
    Create an image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/get',
    description=""" Get a tarball containing all images and metadata for several image repositories.

For each value of the `names` parameter: if it is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned; if it is an image ID, similarly only that image (and its parents) are returned and there would be no names referenced in the 'repositories' file for this image ID.

For details on the format, see [the export image endpoint](#operation/ImageGet).
 """,
    tags=['image_management'],
)
def image_get_all(names: Optional[Names] = None):
    """
    Export several images
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/json',
    description=""" Returns a list of images on the server. Note that it uses a different, smaller representation of an image than inspecting a single image. """,
    tags=['image_management', 'system_monitoring'],
)
def image_list(
    all: Optional[bool] = False,
    filters: Optional[str] = None,
    digests: Optional[bool] = False,
):
    """
    List Images
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/images/load',
    description=""" Load a set of images and tags into a repository.

For details on the format, see [the export image endpoint](#operation/ImageGet).
 """,
    tags=['image_management', 'system_monitoring'],
)
def image_load(quiet: Optional[bool] = False):
    """
    Import images
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/images/prune', tags=['image_management'])
def image_prune(filters: Optional[str] = None):
    """
    Delete unused images
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/search',
    description=""" Search for an image on Docker Hub. """,
    tags=['image_management', 'system_monitoring'],
)
def image_search(term: str, limit: Optional[int] = None, filters: Optional[str] = None):
    """
    Search images
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/images/{name}',
    description=""" Remove an image, along with any untagged parent images that were
referenced by that image.

Images can't be removed if they have descendant images, are being
used by a running container or are being used by a build.
 """,
    tags=['image_management'],
)
def image_delete(
    name: str, force: Optional[bool] = False, noprune: Optional[bool] = False
):
    """
    Remove an image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{name}/get',
    description=""" Get a tarball containing all images and metadata for a repository.

If `name` is a specific name and tag (e.g. `ubuntu:latest`), then only that image (and its parents) are returned. If `name` is an image ID, similarly only that image (and its parents) are returned, but with the exclusion of the `repositories` file in the tarball, as there were no image names referenced.

### Image tarball format

An image tarball contains one directory per image layer (named using its long ID), each containing these files:

- `VERSION`: currently `1.0` - the file format version
- `json`: detailed layer information, similar to `docker inspect layer_id`
- `layer.tar`: A tarfile containing the filesystem changes in this layer

The `layer.tar` file contains `aufs` style `.wh..wh.aufs` files and directories for storing attribute changes and deletions.

If the tarball defines a repository, the tarball should also include a `repositories` file at the root that contains a list of repository and tag names mapped to layer IDs.

```json
{
  "hello-world": {
    "latest": "565a9d68a73f6706862bfe8409a7f659776d4d60a8d096eb4a3cbce6999cc2a1"
  }
}
```
 """,
    tags=['image_management'],
)
def image_get(name: str):
    """
    Export an image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{name}/history',
    description=""" Return parent layers of an image. """,
    tags=['image_management', 'system_monitoring'],
)
def image_history(name: str):
    """
    Get the history of an image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/images/{name}/json',
    description=""" Return low-level information about an image. """,
    tags=['image_management', 'system_monitoring'],
)
def image_inspect(name: str):
    """
    Inspect an image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/images/{name}/push',
    description=""" Push an image to a registry.

If you wish to push an image on to a private registry, that image must already have a tag which references the registry. For example, `registry.example.com/myimage:latest`.

The push is cancelled if the HTTP connection is closed.
 """,
    tags=['image_management'],
)
def image_push(
    name: str,
    tag: Optional[str] = None,
    x__registry__auth: str = Header(..., alias='X-Registry-Auth'),
):
    """
    Push an image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/images/{name}/tag',
    description=""" Tag an image so that it becomes part of a repository. """,
    tags=['image_management'],
)
def image_tag(name: str, repo: Optional[str] = None, tag: Optional[str] = None):
    """
    Tag an image
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/info', tags=['system_health_check', 'system_information', 'system_monitoring']
)
def system_info():
    """
    Get system information
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networks',
    description=""" Returns a list of networks. For details on the format, see [the network inspect endpoint](#operation/NetworkInspect).

Note that it uses a different, smaller representation of a network than inspecting a single network. For example,
the list of containers attached to the network is not propagated in API versions 1.28 and up.
 """,
    tags=['network_management', 'network_operations'],
)
def network_list(filters: Optional[str] = None):
    """
    List networks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/networks/create', tags=['network_management', 'network_operations'])
def network_create(body: NetworksCreatePostRequest):
    """
    Create a network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/networks/prune', tags=['network_management', 'network_operations'])
def network_prune(filters: Optional[str] = None):
    """
    Delete unused networks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/networks/{id}', tags=['network_management', 'network_operations'])
def network_delete(id: str):
    """
    Remove a network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/networks/{id}',
    tags=['network_management', 'network_operations', 'system_monitoring'],
)
def network_inspect(
    id: str, verbose: Optional[bool] = False, scope: Optional[str] = None
):
    """
    Inspect a network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networks/{id}/connect',
    tags=['network_management', 'network_operations', 'container_management'],
)
def network_connect(id: str, request: Request = ...):
    """
    Connect a container to a network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/networks/{id}/disconnect',
    tags=['network_management', 'network_operations', 'container_management'],
)
def network_disconnect(id: str, body: NetworksIdDisconnectPostRequest = ...):
    """
    Disconnect a container from a network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/nodes', tags=['node_management'])
def node_list(filters: Optional[str] = None):
    """
    List nodes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/nodes/{id}', tags=['node_management'])
def node_delete(id: str, force: Optional[bool] = False):
    """
    Delete a node
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/nodes/{id}', tags=['node_management', 'system_health_check'])
def node_inspect(id: str):
    """
    Inspect a node
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/nodes/{id}/update', tags=['node_management'])
def node_update(id: str, version: int = ..., body: NodeSpec = None):
    """
    Update a node
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/plugins',
    description=""" Returns information about installed plugins. """,
    tags=['plugin_management'],
)
def plugin_list(filters: Optional[str] = None):
    """
    List plugins
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/plugins/create', tags=['plugin_management'])
def plugin_create(name: str):
    """
    Create a plugin
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/plugins/privileges', tags=['plugin_management', 'system_information'])
def get_plugin_privileges(remote: str):
    """
    Get plugin privileges
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/plugins/pull',
    description=""" Pulls and installs a plugin. After the plugin is installed, it can be enabled using the [`POST /plugins/{name}/enable` endpoint](#operation/PostPluginsEnable).
 """,
    tags=['plugin_management'],
)
def plugin_pull(
    remote: str,
    name: Optional[str] = None,
    x__registry__auth: Optional[str] = Header(None, alias='X-Registry-Auth'),
    body: PluginsPullPostRequest = None,
):
    """
    Install a plugin
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/plugins/{name}', tags=['plugin_management'])
def plugin_delete(name: str, force: Optional[bool] = False):
    """
    Remove a plugin
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/plugins/{name}/disable', tags=['plugin_management'])
def plugin_disable(name: str):
    """
    Disable a plugin
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/plugins/{name}/enable', tags=['plugin_management'])
def plugin_enable(name: str, timeout: Optional[int] = 0):
    """
    Enable a plugin
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/plugins/{name}/json', tags=['plugin_management'])
def plugin_inspect(name: str):
    """
    Inspect a plugin
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/plugins/{name}/push',
    description=""" Push a plugin to the registry.
 """,
    tags=['plugin_management'],
)
def plugin_push(name: str):
    """
    Push a plugin
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/plugins/{name}/set', tags=['plugin_management'])
def plugin_set(name: str, body: PluginsNameSetPostRequest = None):
    """
    Configure a plugin
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/plugins/{name}/upgrade', tags=['plugin_management'])
def plugin_upgrade(
    name: str,
    remote: str = ...,
    x__registry__auth: Optional[str] = Header(None, alias='X-Registry-Auth'),
    body: PluginsNameUpgradePostRequest = None,
):
    """
    Upgrade a plugin
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/secrets', tags=['secret_management'])
def secret_list(filters: Optional[str] = None):
    """
    List secrets
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/secrets/create', tags=['secret_management'])
def secret_create(body: SecretsCreatePostRequest = None):
    """
    Create a secret
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/secrets/{id}', tags=['secret_management'])
def secret_delete(id: str):
    """
    Delete a secret
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/secrets/{id}', tags=['secret_management'])
def secret_inspect(id: str):
    """
    Inspect a secret
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/secrets/{id}/update', tags=['secret_management', 'config_management'])
def secret_update(id: str, version: int = ..., body: SecretSpec = None):
    """
    Update a Secret
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/services', tags=['service_management'])
def service_list(filters: Optional[str] = None):
    """
    List services
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/services/create', tags=['service_management'])
def service_create(
    x__registry__auth: Optional[str] = Header(None, alias='X-Registry-Auth'),
    body: ServicesCreatePostRequest = ...,
):
    """
    Create a service
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete('/services/{id}', tags=['service_management'])
def service_delete(id: str):
    """
    Delete a service
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/services/{id}', tags=['service_management', 'system_health_check'])
def service_inspect(
    id: str, insert_defaults: Optional[bool] = Query(False, alias='insertDefaults')
):
    """
    Inspect a service
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/services/{id}/logs',
    description=""" Get `stdout` and `stderr` logs from a service.

**Note**: This endpoint works only for services with the `json-file` or `journald` logging drivers.
 """,
    tags=['container_interaction', 'service_management', 'task_management'],
)
def service_logs(
    id: str,
    details: Optional[bool] = False,
    follow: Optional[bool] = False,
    stdout: Optional[bool] = False,
    stderr: Optional[bool] = False,
    since: Optional[int] = 0,
    timestamps: Optional[bool] = False,
    tail: Optional[str] = 'all',
):
    """
    Get service logs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/services/{id}/update', tags=['service_management', 'config_management'])
def service_update(
    id: str,
    version: int = ...,
    registry_auth_from: Optional[str] = Query('spec', alias='registryAuthFrom'),
    rollback: Optional[str] = None,
    x__registry__auth: Optional[str] = Header(None, alias='X-Registry-Auth'),
    body: ServicesIdUpdatePostRequest = ...,
):
    """
    Update a service
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/session',
    description=""" Start a new interactive session with a server. Session allows server to call back to the client for advanced capabilities.

> **Note**: This endpoint is *experimental* and only available if the daemon is started with experimental
> features enabled. The specifications for this endpoint may still change in a future version of the API.

### Hijacking

This endpoint hijacks the HTTP connection to HTTP2 transport that allows the client to expose gPRC services on that connection.

For example, the client sends this request to upgrade the connection:

```
POST /session HTTP/1.1
Upgrade: h2c
Connection: Upgrade
```

The Docker daemon will respond with a `101 UPGRADED` response follow with the raw stream:

```
HTTP/1.1 101 UPGRADED
Connection: Upgrade
Upgrade: h2c
```
 """,
    tags=['system_health_check', 'system_monitoring'],
)
def session():
    """
    Initialize interactive session
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/swarm', tags=['swarm_management', 'system_health_check'])
def swarm_inspect():
    """
    Inspect swarm
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/swarm/init', tags=['swarm_management'])
def swarm_init(body: SwarmInitPostRequest):
    """
    Initialize a new swarm
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/swarm/join', tags=['swarm_management'])
def swarm_join(body: SwarmJoinPostRequest):
    """
    Join an existing swarm
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/swarm/leave', tags=['swarm_management'])
def swarm_leave(force: Optional[bool] = False):
    """
    Leave a swarm
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/swarm/unlock', tags=['swarm_management'])
def swarm_unlock(body: SwarmUnlockPostRequest):
    """
    Unlock a locked manager
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/swarm/unlockkey', tags=['swarm_management', 'secret_management'])
def swarm_unlockkey():
    """
    Get the unlock key
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/swarm/update', tags=['swarm_management', 'config_management'])
def swarm_update(
    version: int,
    rotate_worker_token: Optional[bool] = Query(False, alias='rotateWorkerToken'),
    rotate_manager_token: Optional[bool] = Query(False, alias='rotateManagerToken'),
    rotate_manager_unlock_key: Optional[bool] = Query(
        False, alias='rotateManagerUnlockKey'
    ),
    body: SwarmSpec = ...,
):
    """
    Update a swarm
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/system/df', tags=['system_information', 'system_monitoring'])
def system_data_usage():
    """
    Get data usage information
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/tasks', tags=['task_management'])
def task_list(filters: Optional[str] = None):
    """
    List tasks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/tasks/{id}', tags=['task_management', 'system_monitoring'])
def task_inspect(id: str):
    """
    Inspect a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tasks/{id}/logs',
    description=""" Get `stdout` and `stderr` logs from a task.

**Note**: This endpoint works only for services with the `json-file` or `journald` logging drivers.
 """,
    tags=['task_management', 'container_interaction', 'service_management'],
)
def task_logs(
    id: str,
    details: Optional[bool] = False,
    follow: Optional[bool] = False,
    stdout: Optional[bool] = False,
    stderr: Optional[bool] = False,
    since: Optional[int] = 0,
    timestamps: Optional[bool] = False,
    tail: Optional[str] = 'all',
):
    """
    Get task logs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/version',
    description=""" Returns the version of Docker that is running and various information about the system that Docker is running on. """,
    tags=['system_information'],
)
def system_version():
    """
    Get version
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/volumes', tags=['volume_management'])
def volume_list(filters: Optional[str] = None):
    """
    List volumes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/volumes/create', tags=['volume_management'])
def volume_create(body: VolumesCreatePostRequest):
    """
    Create a volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post('/volumes/prune', tags=['volume_management'])
def volume_prune(filters: Optional[str] = None):
    """
    Delete unused volumes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/volumes/{name}',
    description=""" Instruct the driver to remove the volume. """,
    tags=['volume_management'],
)
def volume_delete(name: str, force: Optional[bool] = False):
    """
    Remove a volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/volumes/{name}', tags=['volume_management'])
def volume_inspect(name: str):
    """
    Inspect a volume
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
