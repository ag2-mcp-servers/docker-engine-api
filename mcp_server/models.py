# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:35:26+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, conint


class Address(BaseModel):
    Addr: Optional[str] = Field(None, description='IP address.')
    PrefixLen: Optional[int] = Field(None, description='Mask length of the IP address.')


class AuthConfig(BaseModel):
    email: Optional[str] = None
    password: Optional[str] = None
    serveraddress: Optional[str] = None
    username: Optional[str] = None


class Commit(BaseModel):
    Expected: Optional[str] = Field(
        None,
        description='Commit ID of external tool expected by dockerd as set at build time.\n',
        examples=['2d41c047c83e09a6d61d464906feb2a2f3c52aa4'],
    )
    ID: Optional[str] = Field(
        None,
        description='Actual commit ID of external tool.',
        examples=['cfb82a876ecc11b5ca0977d1733adbe58599088a'],
    )


class ConfigSpec(BaseModel):
    Data: Optional[str] = Field(
        None,
        description='Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-3.2))\nconfig data.\n',
    )
    Labels: Optional[Dict[str, str]] = Field(
        None, description='User-defined key/value metadata.'
    )
    Name: Optional[str] = Field(None, description='User-defined name of the config.')


class Volumes(BaseModel):
    additionalProperties: Optional[Dict[str, Any]] = {}


class HostConfig(BaseModel):
    NetworkMode: Optional[str] = None


class DeviceMapping(BaseModel):
    CgroupPermissions: Optional[str] = None
    PathInContainer: Optional[str] = None
    PathOnHost: Optional[str] = None


class Driver(BaseModel):
    Name: str = Field(..., description='Name of the driver.', examples=['some-driver'])
    Options: Optional[Dict[str, str]] = Field(
        None,
        description='Key/value map of driver-specific options.',
        examples=[
            {
                'OptionA': 'value for driver-specific option A',
                'OptionB': 'value for driver-specific option B',
            }
        ],
    )


class EndpointIPAMConfig(BaseModel):
    IPv4Address: Optional[str] = Field(None, examples=['172.20.30.33'])
    IPv6Address: Optional[str] = Field(None, examples=['2001:db8:abcd::3033'])
    LinkLocalIPs: Optional[List[str]] = Field(
        None, examples=[['169.254.34.68', 'fe80::3468']]
    )


class Protocol(Enum):
    tcp = 'tcp'
    udp = 'udp'


class EndpointPortConfig(BaseModel):
    Name: Optional[str] = None
    Protocol_1: Optional[Protocol] = Field(None, alias='Protocol')
    PublishedPort: Optional[int] = Field(
        None, description='The port on the swarm hosts.'
    )
    TargetPort: Optional[int] = Field(
        None, description='The port inside the container.'
    )


class EndpointSettings(BaseModel):
    Aliases: Optional[List[str]] = Field(None, examples=[['server_x', 'server_y']])
    DriverOpts: Optional[Dict[str, str]] = Field(
        None,
        description='DriverOpts is a mapping of driver options and values. These options\nare passed directly to the driver and are driver specific.\n',
        examples=[
            {
                'com.example.some-label': 'some-value',
                'com.example.some-other-label': 'some-other-value',
            }
        ],
    )
    EndpointID: Optional[str] = Field(
        None,
        description='Unique ID for the service endpoint in a Sandbox.\n',
        examples=['b88f5b905aabf2893f3cbc4ee42d1ea7980bbc0a92e2c8922b1e1795298afb0b'],
    )
    Gateway: Optional[str] = Field(
        None, description='Gateway address for this network.\n', examples=['172.17.0.1']
    )
    GlobalIPv6Address: Optional[str] = Field(
        None, description='Global IPv6 address.\n', examples=['2001:db8::5689']
    )
    GlobalIPv6PrefixLen: Optional[int] = Field(
        None, description='Mask length of the global IPv6 address.\n', examples=[64]
    )
    IPAMConfig: Optional[EndpointIPAMConfig] = None
    IPAddress: Optional[str] = Field(
        None, description='IPv4 address.\n', examples=['172.17.0.4']
    )
    IPPrefixLen: Optional[int] = Field(
        None, description='Mask length of the IPv4 address.\n', examples=[16]
    )
    IPv6Gateway: Optional[str] = Field(
        None, description='IPv6 gateway address.\n', examples=['2001:db8:2::100']
    )
    Links: Optional[List[str]] = Field(None, examples=[['container_1', 'container_2']])
    MacAddress: Optional[str] = Field(
        None,
        description='MAC address for the endpoint on this network.\n',
        examples=['02:42:ac:11:00:04'],
    )
    NetworkID: Optional[str] = Field(
        None,
        description='Unique ID of the network.\n',
        examples=['08754567f1f40222263eab4102e1c733ae697e8e354aa9cd6e18d7402835292a'],
    )


class Mode(Enum):
    vip = 'vip'
    dnsrr = 'dnsrr'


class EndpointSpec(BaseModel):
    Mode_1: Optional[Mode] = Field(
        'vip',
        alias='Mode',
        description='The mode of resolution to use for internal load balancing between tasks.',
    )
    Ports: Optional[List[EndpointPortConfig]] = Field(
        None,
        description='List of exposed ports that this service is accessible on from the outside. Ports can only be provided if `vip` resolution mode is used.',
    )


class Plugin(BaseModel):
    Name: Optional[str] = None
    Type: Optional[str] = None


class EngineDescription(BaseModel):
    EngineVersion: Optional[str] = Field(None, examples=['17.06.0'])
    Labels: Optional[Dict[str, str]] = Field(None, examples=[{'foo': 'bar'}])
    Plugins: Optional[List[Plugin]] = Field(
        None,
        examples=[
            [
                {'Name': 'awslogs', 'Type': 'Log'},
                {'Name': 'fluentd', 'Type': 'Log'},
                {'Name': 'gcplogs', 'Type': 'Log'},
                {'Name': 'gelf', 'Type': 'Log'},
                {'Name': 'journald', 'Type': 'Log'},
                {'Name': 'json-file', 'Type': 'Log'},
                {'Name': 'logentries', 'Type': 'Log'},
                {'Name': 'splunk', 'Type': 'Log'},
                {'Name': 'syslog', 'Type': 'Log'},
                {'Name': 'bridge', 'Type': 'Network'},
                {'Name': 'host', 'Type': 'Network'},
                {'Name': 'ipvlan', 'Type': 'Network'},
                {'Name': 'macvlan', 'Type': 'Network'},
                {'Name': 'null', 'Type': 'Network'},
                {'Name': 'overlay', 'Type': 'Network'},
                {'Name': 'local', 'Type': 'Volume'},
                {'Name': 'localhost:5000/vieux/sshfs:latest', 'Type': 'Volume'},
                {'Name': 'vieux/sshfs:latest', 'Type': 'Volume'},
            ]
        ],
    )


class ErrorDetail(BaseModel):
    code: Optional[int] = None
    message: Optional[str] = None


class ErrorResponse(BaseModel):
    message: str = Field(..., description='The error message.')


class DiscreteResourceSpec(BaseModel):
    Kind: Optional[str] = None
    Value: Optional[int] = None


class NamedResourceSpec(BaseModel):
    Kind: Optional[str] = None
    Value: Optional[str] = None


class GenericResource(BaseModel):
    DiscreteResourceSpec_1: Optional[DiscreteResourceSpec] = Field(
        None, alias='DiscreteResourceSpec'
    )
    NamedResourceSpec_1: Optional[NamedResourceSpec] = Field(
        None, alias='NamedResourceSpec'
    )


class GenericResources(RootModel[List[GenericResource]]):
    root: List[GenericResource] = Field(
        ...,
        description='User-defined resources can be either Integer resources (e.g, `SSD=3`) or String resources (e.g, `GPU=UUID1`)',
        examples=[
            [
                {'DiscreteResourceSpec': {'Kind': 'SSD', 'Value': 3}},
                {'NamedResourceSpec': {'Kind': 'GPU', 'Value': 'UUID1'}},
                {'NamedResourceSpec': {'Kind': 'GPU', 'Value': 'UUID2'}},
            ]
        ],
    )


class GraphDriverData(BaseModel):
    Data: Dict[str, str]
    Name: str


class HealthConfig(BaseModel):
    Interval: Optional[int] = Field(
        None,
        description='The time to wait between checks in nanoseconds. It should be 0 or at least 1000000 (1 ms). 0 means inherit.',
    )
    Retries: Optional[int] = Field(
        None,
        description='The number of consecutive failures needed to consider a container as unhealthy. 0 means inherit.',
    )
    StartPeriod: Optional[int] = Field(
        None,
        description='Start period for the container to initialize before starting health-retries countdown in nanoseconds. It should be 0 or at least 1000000 (1 ms). 0 means inherit.',
    )
    Test: Optional[List[str]] = Field(
        None,
        description='The test to perform. Possible values are:\n\n- `[]` inherit healthcheck from image or parent image\n- `["NONE"]` disable healthcheck\n- `["CMD", args...]` exec arguments directly\n- `["CMD-SHELL", command]` run command with system\'s default shell\n',
    )
    Timeout: Optional[int] = Field(
        None,
        description='The time to wait before considering the check to have hung. It should be 0 or at least 1000000 (1 ms). 0 means inherit.',
    )


class ConsoleSizeItem(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class Isolation(Enum):
    default = 'default'
    process = 'process'
    hyperv = 'hyperv'


class Type(Enum):
    json_file = 'json-file'
    syslog = 'syslog'
    journald = 'journald'
    gelf = 'gelf'
    fluentd = 'fluentd'
    awslogs = 'awslogs'
    splunk = 'splunk'
    etwlogs = 'etwlogs'
    none = 'none'


class LogConfig(BaseModel):
    Config: Optional[Dict[str, str]] = None
    Type_1: Optional[Type] = Field(None, alias='Type')


class PortBindings(BaseModel):
    HostIp: Optional[str] = Field(None, description='The host IP address')
    HostPort: Optional[str] = Field(
        None, description='The host port number, as a string'
    )


class IPAM(BaseModel):
    Config: Optional[List[Dict[str, str]]] = Field(
        None,
        description='List of IPAM configuration options, specified as a map: `{"Subnet": <CIDR>, "IPRange": <CIDR>, "Gateway": <IP address>, "AuxAddress": <device_name:IP address>}`',
    )
    Driver: Optional[str] = Field(
        'default', description='Name of the IPAM driver to use.'
    )
    Options: Optional[List[Dict[str, str]]] = Field(
        None, description='Driver-specific options, specified as a map.'
    )


class IdResponse(BaseModel):
    Id: str = Field(..., description='The id of the newly created object.')


class Metadata(BaseModel):
    LastTagTime: Optional[str] = None


class RootFS(BaseModel):
    BaseLayer: Optional[str] = None
    Layers: Optional[List[str]] = None
    Type: str


class ImageDeleteResponseItem(BaseModel):
    Deleted: Optional[str] = Field(
        None, description='The image ID of an image that was deleted'
    )
    Untagged: Optional[str] = Field(
        None, description='The image ID of an image that was untagged'
    )


class ImageSummary(BaseModel):
    Containers: int
    Created: int
    Id: str
    Labels: Dict[str, str]
    ParentId: str
    RepoDigests: List[str]
    RepoTags: List[str]
    SharedSize: int
    Size: int
    VirtualSize: int


class IndexInfo(BaseModel):
    Mirrors: Optional[List[str]] = Field(
        None,
        description='List of mirrors, expressed as URIs.\n',
        examples=[
            [
                'https://hub-mirror.corp.example.com:5000/',
                'https://registry-2.docker.io/',
                'https://registry-3.docker.io/',
            ]
        ],
    )
    Name: Optional[str] = Field(
        None,
        description='Name of the registry, such as "docker.io".\n',
        examples=['docker.io'],
    )
    Official: Optional[bool] = Field(
        None,
        description='Indicates whether this is an official registry (i.e., Docker Hub / docker.io)\n',
        examples=[True],
    )
    Secure: Optional[bool] = Field(
        None,
        description="Indicates if the the registry is part of the list of insecure\nregistries.\n\nIf `false`, the registry is insecure. Insecure registries accept\nun-encrypted (HTTP) and/or untrusted (HTTPS with certificates from\nunknown CAs) communication.\n\n> **Warning**: Insecure registries can be useful when running a local\n> registry. However, because its use creates security vulnerabilities\n> it should ONLY be enabled for testing purposes. For increased\n> security, users should add their CA to their system's list of\n> trusted CAs instead of enabling this option.\n",
        examples=[True],
    )


class JoinTokens(BaseModel):
    Manager: Optional[str] = Field(
        None,
        description='The token managers can use to join the swarm.\n',
        examples=[
            'SWMTKN-1-3pu6hszjas19xyp7ghgosyx9k8atbfcr8p2is99znpy26u2lkl-7p73s1dx5in4tatdymyhg9hu2'
        ],
    )
    Worker: Optional[str] = Field(
        None,
        description='The token workers can use to join the swarm.\n',
        examples=[
            'SWMTKN-1-3pu6hszjas19xyp7ghgosyx9k8atbfcr8p2is99znpy26u2lkl-1awxwuwd3z9j1z3puu7rcgdbx'
        ],
    )


class LocalNodeState(Enum):
    field_ = ''
    inactive = 'inactive'
    pending = 'pending'
    active = 'active'
    error = 'error'
    locked = 'locked'


class Propagation(Enum):
    private = 'private'
    rprivate = 'rprivate'
    shared = 'shared'
    rshared = 'rshared'
    slave = 'slave'
    rslave = 'rslave'


class BindOptions(BaseModel):
    Propagation_1: Optional[Propagation] = Field(
        None,
        alias='Propagation',
        description='A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`.',
    )


class TmpfsOptions(BaseModel):
    Mode: Optional[int] = Field(
        None, description='The permission mode for the tmpfs mount in an integer.'
    )
    SizeBytes: Optional[int] = Field(
        None, description='The size for the tmpfs mount in bytes.'
    )


class Type1(Enum):
    bind = 'bind'
    volume = 'volume'
    tmpfs = 'tmpfs'


class DriverConfig(BaseModel):
    Name: Optional[str] = Field(
        None, description='Name of the driver to use to create the volume.'
    )
    Options: Optional[Dict[str, str]] = Field(
        None, description='key/value map of driver specific options.'
    )


class VolumeOptions(BaseModel):
    DriverConfig_1: Optional[DriverConfig] = Field(
        None, alias='DriverConfig', description='Map of driver specific options'
    )
    Labels: Optional[Dict[str, str]] = Field(
        None, description='User-defined key/value metadata.'
    )
    NoCopy: Optional[bool] = Field(
        False, description='Populate volume with data from the target.'
    )


class Mount(BaseModel):
    BindOptions_1: Optional[BindOptions] = Field(
        None,
        alias='BindOptions',
        description='Optional configuration for the `bind` type.',
    )
    Consistency: Optional[str] = Field(
        None,
        description='The consistency requirement for the mount: `default`, `consistent`, `cached`, or `delegated`.',
    )
    ReadOnly: Optional[bool] = Field(
        None, description='Whether the mount should be read-only.'
    )
    Source: Optional[str] = Field(
        None, description='Mount source (e.g. a volume name, a host path).'
    )
    Target: Optional[str] = Field(None, description='Container path.')
    TmpfsOptions_1: Optional[TmpfsOptions] = Field(
        None,
        alias='TmpfsOptions',
        description='Optional configuration for the `tmpfs` type.',
    )
    Type: Optional[Type1] = Field(
        None,
        description='The mount type. Available types:\n\n- `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container.\n- `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed.\n- `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.\n',
    )
    VolumeOptions_1: Optional[VolumeOptions] = Field(
        None,
        alias='VolumeOptions',
        description='Optional configuration for the `volume` type.',
    )


class MountPoint(BaseModel):
    Destination: Optional[str] = None
    Driver: Optional[str] = None
    Mode: Optional[str] = None
    Name: Optional[str] = None
    Propagation: Optional[str] = None
    RW: Optional[bool] = None
    Source: Optional[str] = None
    Type: Optional[str] = None


class NetworkContainer(BaseModel):
    EndpointID: Optional[str] = None
    IPv4Address: Optional[str] = None
    IPv6Address: Optional[str] = None
    MacAddress: Optional[str] = None
    Name: Optional[str] = None


class Availability(Enum):
    active = 'active'
    pause = 'pause'
    drain = 'drain'


class Role(Enum):
    worker = 'worker'
    manager = 'manager'


class NodeSpec(BaseModel):
    Availability_1: Optional[Availability] = Field(
        None,
        alias='Availability',
        description='Availability of the node.',
        examples=['active'],
    )
    Labels: Optional[Dict[str, str]] = Field(
        None, description='User-defined key/value metadata.'
    )
    Name: Optional[str] = Field(
        None, description='Name for the node.', examples=['my-node']
    )
    Role_1: Optional[Role] = Field(
        None, alias='Role', description='Role of the node.', examples=['manager']
    )


class NodeState(Enum):
    unknown = 'unknown'
    down = 'down'
    ready = 'ready'
    disconnected = 'disconnected'


class NodeStatus(BaseModel):
    Addr: Optional[str] = Field(
        None, description='IP address of the node.', examples=['172.17.0.2']
    )
    Message: Optional[str] = Field(None, examples=[''])
    State: Optional[NodeState] = None


class ObjectVersion(BaseModel):
    Index: Optional[int] = Field(None, examples=[373531])


class PeerNode(BaseModel):
    Addr: Optional[str] = Field(
        None, description='IP address and ports at which this node can be reached.\n'
    )
    NodeID: Optional[str] = Field(
        None, description='Unique identifier of for this node in the swarm.'
    )


class Platform(BaseModel):
    Architecture: Optional[str] = Field(
        None,
        description='Architecture represents the hardware architecture (for example,\n`x86_64`).\n',
        examples=['x86_64'],
    )
    OS: Optional[str] = Field(
        None,
        description='OS represents the Operating System (for example, `linux` or `windows`).\n',
        examples=['linux'],
    )


class Args(BaseModel):
    Description: str = Field(..., examples=['command line arguments'])
    Name: str = Field(..., examples=['args'])
    Settable: List[str]
    Value: List[str]


class Network1(BaseModel):
    Type: str = Field(..., examples=['host'])


class User(BaseModel):
    GID: Optional[int] = Field(None, examples=[1000])
    UID: Optional[int] = Field(None, examples=[1000])


class Rootfs(BaseModel):
    diff_ids: Optional[List[str]] = Field(
        None,
        examples=[
            [
                'sha256:675532206fbf3030b8458f88d6e26d4eb1577688a25efec97154c94e8b6b4887',
                'sha256:e216a057b1cb1efc11f8a268f37ef62083e70b1b38323ba252e25ac88904a7e8',
            ]
        ],
    )
    type: Optional[str] = Field(None, examples=['layers'])


class PluginDevice(BaseModel):
    Description: str
    Name: str
    Path: str = Field(..., examples=['/dev/fuse'])
    Settable: List[str]


class PluginEnv(BaseModel):
    Description: str
    Name: str
    Settable: List[str]
    Value: str


class PluginInterfaceType(BaseModel):
    Capability: str
    Prefix: str
    Version: str


class PluginMount(BaseModel):
    Description: str = Field(
        ..., examples=["This is a mount that's used by the plugin."]
    )
    Destination: str = Field(..., examples=['/mnt/state'])
    Name: str = Field(..., examples=['some-mount'])
    Options: List[str] = Field(..., examples=[['rbind', 'rw']])
    Settable: List[str]
    Source: str = Field(..., examples=['/var/lib/docker/plugins/'])
    Type: str = Field(..., examples=['bind'])


class PluginsInfo(BaseModel):
    Authorization: Optional[List[str]] = Field(
        None,
        description='Names of available authorization plugins.',
        examples=[['img-authz-plugin', 'hbm']],
    )
    Log: Optional[List[str]] = Field(
        None,
        description='Names of available logging-drivers, and logging-driver plugins.',
        examples=[
            [
                'awslogs',
                'fluentd',
                'gcplogs',
                'gelf',
                'journald',
                'json-file',
                'logentries',
                'splunk',
                'syslog',
            ]
        ],
    )
    Network: Optional[List[str]] = Field(
        None,
        description='Names of available network-drivers, and network-driver plugins.',
        examples=[['bridge', 'host', 'ipvlan', 'macvlan', 'null', 'overlay']],
    )
    Volume: Optional[List[str]] = Field(
        None,
        description='Names of available volume-drivers, and network-driver plugins.',
        examples=[['local']],
    )


class Type2(Enum):
    tcp = 'tcp'
    udp = 'udp'


class Port(BaseModel):
    IP: Optional[str] = None
    PrivatePort: int = Field(..., description='Port on the container')
    PublicPort: Optional[int] = Field(None, description='Port exposed on the host')
    Type: Type2


class PortBinding(BaseModel):
    HostIp: Optional[str] = Field(
        None,
        description="Host IP address that the container's port is mapped to.",
        examples=['127.0.0.1'],
    )
    HostPort: Optional[str] = Field(
        None,
        description="Host port number that the container's port is mapped to.",
        examples=['4443'],
    )


class PortMap(RootModel[Optional[Dict[str, List[PortBinding]]]]):
    root: Optional[Dict[str, List[PortBinding]]] = None


class ProcessConfig(BaseModel):
    arguments: Optional[List[str]] = None
    entrypoint: Optional[str] = None
    privileged: Optional[bool] = None
    tty: Optional[bool] = None
    user: Optional[str] = None


class ProgressDetail(BaseModel):
    code: Optional[int] = None
    message: Optional[int] = None


class PushImageInfo(BaseModel):
    error: Optional[str] = None
    progress: Optional[str] = None
    progressDetail: Optional[ProgressDetail] = None
    status: Optional[str] = None


class Reachability(Enum):
    unknown = 'unknown'
    unreachable = 'unreachable'
    reachable = 'reachable'


class RegistryServiceConfig(BaseModel):
    AllowNondistributableArtifactsCIDRs: Optional[List[str]] = Field(
        None,
        description='List of IP ranges to which nondistributable artifacts can be pushed,\nusing the CIDR syntax [RFC 4632](https://tools.ietf.org/html/4632).\n\nSome images (for example, Windows base images) contain artifacts\nwhose distribution is restricted by license. When these images are\npushed to a registry, restricted artifacts are not included.\n\nThis configuration override this behavior, and enables the daemon to\npush nondistributable artifacts to all registries whose resolved IP\naddress is within the subnet described by the CIDR syntax.\n\nThis option is useful when pushing images containing\nnondistributable artifacts to a registry on an air-gapped network so\nhosts on that network can pull the images without connecting to\nanother server.\n\n> **Warning**: Nondistributable artifacts typically have restrictions\n> on how and where they can be distributed and shared. Only use this\n> feature to push artifacts to private registries and ensure that you\n> are in compliance with any terms that cover redistributing\n> nondistributable artifacts.\n',
        examples=[['::1/128', '127.0.0.0/8']],
    )
    AllowNondistributableArtifactsHostnames: Optional[List[str]] = Field(
        None,
        description='List of registry hostnames to which nondistributable artifacts can be\npushed, using the format `<hostname>[:<port>]` or `<IP address>[:<port>]`.\n\nSome images (for example, Windows base images) contain artifacts\nwhose distribution is restricted by license. When these images are\npushed to a registry, restricted artifacts are not included.\n\nThis configuration override this behavior for the specified\nregistries.\n\nThis option is useful when pushing images containing\nnondistributable artifacts to a registry on an air-gapped network so\nhosts on that network can pull the images without connecting to\nanother server.\n\n> **Warning**: Nondistributable artifacts typically have restrictions\n> on how and where they can be distributed and shared. Only use this\n> feature to push artifacts to private registries and ensure that you\n> are in compliance with any terms that cover redistributing\n> nondistributable artifacts.\n',
        examples=[
            ['registry.internal.corp.example.com:3000', '[2001:db8:a0b:12f0::1]:443']
        ],
    )
    IndexConfigs: Optional[Dict[str, IndexInfo]] = Field(
        None,
        examples=[
            {
                '127.0.0.1:5000': {
                    'Mirrors': [],
                    'Name': '127.0.0.1:5000',
                    'Official': False,
                    'Secure': False,
                },
                '[2001:db8:a0b:12f0::1]:80': {
                    'Mirrors': [],
                    'Name': '[2001:db8:a0b:12f0::1]:80',
                    'Official': False,
                    'Secure': False,
                },
                'docker.io': {
                    'Mirrors': ['https://hub-mirror.corp.example.com:5000/'],
                    'Name': 'docker.io',
                    'Official': True,
                    'Secure': True,
                },
                'registry.internal.corp.example.com:3000': {
                    'Mirrors': [],
                    'Name': 'registry.internal.corp.example.com:3000',
                    'Official': False,
                    'Secure': False,
                },
            }
        ],
    )
    InsecureRegistryCIDRs: Optional[List[str]] = Field(
        None,
        description="List of IP ranges of insecure registries, using the CIDR syntax\n([RFC 4632](https://tools.ietf.org/html/4632)). Insecure registries\naccept un-encrypted (HTTP) and/or untrusted (HTTPS with certificates\nfrom unknown CAs) communication.\n\nBy default, local registries (`127.0.0.0/8`) are configured as\ninsecure. All other registries are secure. Communicating with an\ninsecure registry is not possible if the daemon assumes that registry\nis secure.\n\nThis configuration override this behavior, insecure communication with\nregistries whose resolved IP address is within the subnet described by\nthe CIDR syntax.\n\nRegistries can also be marked insecure by hostname. Those registries\nare listed under `IndexConfigs` and have their `Secure` field set to\n`false`.\n\n> **Warning**: Using this option can be useful when running a local\n> registry, but introduces security vulnerabilities. This option\n> should therefore ONLY be used for testing purposes. For increased\n> security, users should add their CA to their system's list of trusted\n> CAs instead of enabling this option.\n",
        examples=[['::1/128', '127.0.0.0/8']],
    )
    Mirrors: Optional[List[str]] = Field(
        None,
        description='List of registry URLs that act as a mirror for the official\n(`docker.io`) registry.\n',
        examples=[
            [
                'https://hub-mirror.corp.example.com:5000/',
                'https://[2001:db8:a0b:12f0::1]/',
            ]
        ],
    )


class ResourceObject(BaseModel):
    GenericResources_1: Optional[GenericResources] = Field(
        None, alias='GenericResources'
    )
    MemoryBytes: Optional[int] = Field(None, examples=[8272408576])
    NanoCPUs: Optional[int] = Field(None, examples=[4000000000])


class BlkioWeightDeviceItem(BaseModel):
    Path: Optional[str] = None
    Weight: Optional[conint(ge=0)] = None


class Ulimit(BaseModel):
    Hard: Optional[int] = Field(None, description='Hard limit')
    Name: Optional[str] = Field(None, description='Name of ulimit')
    Soft: Optional[int] = Field(None, description='Soft limit')


class Name(Enum):
    field_ = ''
    always = 'always'
    unless_stopped = 'unless-stopped'
    on_failure = 'on-failure'


class RestartPolicy(BaseModel):
    MaximumRetryCount: Optional[int] = Field(
        None,
        description='If `on-failure` is used, the number of times to retry before giving up',
    )
    Name_1: Optional[Name] = Field(
        None,
        alias='Name',
        description='- Empty string means not to restart\n- `always` Always restart\n- `unless-stopped` Restart always except when the user has manually stopped the container\n- `on-failure` Restart only when the container exit code is non-zero\n',
    )


class Runtime(BaseModel):
    path: Optional[str] = Field(
        None,
        description="Name and, optional, path, of the OCI executable binary.\n\nIf the path is omitted, the daemon searches the host's `$PATH` for the\nbinary and uses the first result.\n",
        examples=['/usr/local/bin/my-oci-runtime'],
    )
    runtimeArgs: Optional[List[str]] = Field(
        None,
        description='List of command-line arguments to pass to the runtime when invoked.\n',
        examples=[['--debug', '--systemd-cgroup=false']],
    )


class SecretSpec(BaseModel):
    Data: Optional[str] = Field(
        None,
        description='Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-3.2))\ndata to store as secret.\n\nThis field is only used to _create_ a secret, and is not returned by\nother endpoints.\n',
        examples=[''],
    )
    Driver_1: Optional[Driver] = Field(None, alias='Driver')
    Labels: Optional[Dict[str, str]] = Field(
        None,
        description='User-defined key/value metadata.',
        examples=[
            {
                'com.example.some-label': 'some-value',
                'com.example.some-other-label': 'some-other-value',
            }
        ],
    )
    Name: Optional[str] = Field(None, description='User-defined name of the secret.')


class VirtualIP(BaseModel):
    Addr: Optional[str] = None
    NetworkID: Optional[str] = None


class Endpoint(BaseModel):
    Ports: Optional[List[EndpointPortConfig]] = None
    Spec: Optional[EndpointSpec] = None
    VirtualIPs: Optional[List[VirtualIP]] = None


class State(Enum):
    updating = 'updating'
    paused = 'paused'
    completed = 'completed'


class UpdateStatus(BaseModel):
    CompletedAt: Optional[str] = None
    Message: Optional[str] = None
    StartedAt: Optional[str] = None
    State_1: Optional[State] = Field(None, alias='State')


class Replicated(BaseModel):
    Replicas: Optional[int] = None


class Mode1(BaseModel):
    Global: Optional[Dict[str, Any]] = None
    Replicated_1: Optional[Replicated] = Field(None, alias='Replicated')


class Network2(BaseModel):
    Aliases: Optional[List[str]] = None
    Target: Optional[str] = None


class FailureAction(Enum):
    continue_ = 'continue'
    pause = 'pause'


class Order(Enum):
    stop_first = 'stop-first'
    start_first = 'start-first'


class RollbackConfig(BaseModel):
    Delay: Optional[int] = Field(
        None, description='Amount of time between rollback iterations, in nanoseconds.'
    )
    FailureAction_1: Optional[FailureAction] = Field(
        None,
        alias='FailureAction',
        description='Action to take if an rolled back task fails to run, or stops running during the rollback.',
    )
    MaxFailureRatio: Optional[float] = Field(
        0,
        description='The fraction of tasks that may fail during a rollback before the failure action is invoked, specified as a floating point number between 0 and 1.',
    )
    Monitor: Optional[int] = Field(
        None,
        description='Amount of time to monitor each rolled back task for failures, in nanoseconds.',
    )
    Order_1: Optional[Order] = Field(
        None,
        alias='Order',
        description='The order of operations when rolling back a task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.',
    )
    Parallelism: Optional[int] = Field(
        None,
        description='Maximum number of tasks to be rolled back in one iteration (0 means unlimited parallelism).',
    )


class FailureAction1(Enum):
    continue_ = 'continue'
    pause = 'pause'
    rollback = 'rollback'


class UpdateConfig(BaseModel):
    Delay: Optional[int] = Field(
        None, description='Amount of time between updates, in nanoseconds.'
    )
    FailureAction: Optional[FailureAction1] = Field(
        None,
        description='Action to take if an updated task fails to run, or stops running during the update.',
    )
    MaxFailureRatio: Optional[float] = Field(
        0,
        description='The fraction of tasks that may fail during an update before the failure action is invoked, specified as a floating point number between 0 and 1.',
    )
    Monitor: Optional[int] = Field(
        None,
        description='Amount of time to monitor each updated task for failures, in nanoseconds.',
    )
    Order_1: Optional[Order] = Field(
        None,
        alias='Order',
        description='The order of operations when rolling out an updated task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.',
    )
    Parallelism: Optional[int] = Field(
        None,
        description='Maximum number of tasks to be updated in one iteration (0 means unlimited parallelism).',
    )


class ServiceUpdateResponse(BaseModel):
    Warnings: Optional[List[str]] = Field(None, description='Optional warning messages')


class Protocol1(Enum):
    cfssl = 'cfssl'


class ExternalCA(BaseModel):
    CACert: Optional[str] = Field(
        None,
        description='The root CA certificate (in PEM format) this external CA uses to issue TLS certificates (assumed to be to the current swarm root CA certificate if not provided).',
    )
    Options: Optional[Dict[str, str]] = Field(
        None,
        description='An object with key/value pairs that are interpreted as protocol-specific options for the external CA driver.',
    )
    Protocol: Optional[Protocol1] = Field(
        'cfssl',
        description='Protocol for communication with the external CA (currently only `cfssl` is supported).',
    )
    URL: Optional[str] = Field(
        None, description='URL where certificate signing requests should be sent.'
    )


class CAConfig(BaseModel):
    ExternalCAs: Optional[List[ExternalCA]] = Field(
        None,
        description='Configuration for forwarding signing requests to an external certificate authority.',
    )
    ForceRotate: Optional[int] = Field(
        None,
        description='An integer whose purpose is to force swarm to generate a new signing CA certificate and key, if none have been specified in `SigningCACert` and `SigningCAKey`',
    )
    NodeCertExpiry: Optional[int] = Field(
        None,
        description='The duration node certificates are issued for.',
        examples=[7776000000000000],
    )
    SigningCACert: Optional[str] = Field(
        None,
        description='The desired signing CA certificate for all swarm node TLS leaf certificates, in PEM format.',
    )
    SigningCAKey: Optional[str] = Field(
        None,
        description='The desired signing CA key for all swarm node TLS leaf certificates, in PEM format.',
    )


class Dispatcher(BaseModel):
    HeartbeatPeriod: Optional[int] = Field(
        None,
        description='The delay for an agent to send a heartbeat to the dispatcher.',
        examples=[5000000000],
    )


class EncryptionConfig(BaseModel):
    AutoLockManagers: Optional[bool] = Field(
        None,
        description='If set, generate a key and use it to lock data stored on the managers.',
        examples=[False],
    )


class Orchestration(BaseModel):
    TaskHistoryRetentionLimit: Optional[int] = Field(
        None,
        description='The number of historic tasks to keep per instance or node. If negative, never remove completed or failed tasks.',
        examples=[10],
    )


class Raft(BaseModel):
    ElectionTick: Optional[int] = Field(
        None,
        description='The number of ticks that a follower will wait for a message from the leader before becoming a candidate and starting an election. `ElectionTick` must be greater than `HeartbeatTick`.\n\nA tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed.\n',
        examples=[3],
    )
    HeartbeatTick: Optional[int] = Field(
        None,
        description='The number of ticks between heartbeats. Every HeartbeatTick ticks, the leader will send a heartbeat to the followers.\n\nA tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed.\n',
        examples=[1],
    )
    KeepOldSnapshots: Optional[int] = Field(
        None, description='The number of snapshots to keep beyond the current snapshot.'
    )
    LogEntriesForSlowFollowers: Optional[int] = Field(
        None,
        description='The number of log entries to keep around to sync up slow followers after a snapshot is created.',
        examples=[500],
    )
    SnapshotInterval: Optional[int] = Field(
        None,
        description='The number of log entries between snapshots.',
        examples=[10000],
    )


class LogDriver(BaseModel):
    Name: Optional[str] = Field(
        None,
        description='The log driver to use as a default for new tasks.\n',
        examples=['json-file'],
    )
    Options: Optional[Dict[str, str]] = Field(
        None,
        description='Driver-specific options for the selectd log driver, specified\nas key/value pairs.\n',
        examples=[{'max-file': '10', 'max-size': '100m'}],
    )


class TaskDefaults(BaseModel):
    LogDriver_1: Optional[LogDriver] = Field(
        None,
        alias='LogDriver',
        description='The log driver to use for tasks created in the orchestrator if\nunspecified by a service.\n\nUpdating this value only affects new tasks. Existing tasks continue\nto use their previously configured log driver until recreated.\n',
    )


class SwarmSpec(BaseModel):
    CAConfig_1: Optional[CAConfig] = Field(
        None, alias='CAConfig', description='CA configuration.'
    )
    Dispatcher_1: Optional[Dispatcher] = Field(
        None, alias='Dispatcher', description='Dispatcher configuration.'
    )
    EncryptionConfig_1: Optional[EncryptionConfig] = Field(
        None,
        alias='EncryptionConfig',
        description='Parameters related to encryption-at-rest.',
    )
    Labels: Optional[Dict[str, str]] = Field(
        None,
        description='User-defined key/value metadata.',
        examples=[
            {
                'com.example.corp.department': 'engineering',
                'com.example.corp.type': 'production',
            }
        ],
    )
    Name: Optional[str] = Field(
        None, description='Name of the swarm.', examples=['default']
    )
    Orchestration_1: Optional[Orchestration] = Field(
        None, alias='Orchestration', description='Orchestration configuration.'
    )
    Raft_1: Optional[Raft] = Field(
        None, alias='Raft', description='Raft configuration.'
    )
    TaskDefaults_1: Optional[TaskDefaults] = Field(
        None,
        alias='TaskDefaults',
        description='Defaults for creating tasks in this cluster.',
    )


class CgroupDriver(Enum):
    cgroupfs = 'cgroupfs'
    systemd = 'systemd'


class Isolation1(Enum):
    default = 'default'
    hyperv = 'hyperv'
    process = 'process'


class TLSInfo(BaseModel):
    CertIssuerPublicKey: Optional[str] = Field(
        None,
        description='The base64-url-safe-encoded raw public key bytes of the issuer',
    )
    CertIssuerSubject: Optional[str] = Field(
        None, description='The base64-url-safe-encoded raw subject bytes of the issuer'
    )
    TrustRoot: Optional[str] = Field(
        None,
        description='The root CA certificate(s) that are used to validate leaf TLS certificates',
    )


class ContainerStatus(BaseModel):
    ContainerID: Optional[str] = None
    ExitCode: Optional[int] = None
    PID: Optional[int] = None


class File(BaseModel):
    GID: Optional[str] = Field(None, description='GID represents the file GID.')
    Mode: Optional[int] = Field(
        None, description='Mode represents the FileMode of the file.'
    )
    Name: Optional[str] = Field(
        None, description='Name represents the final filename in the filesystem.'
    )
    UID: Optional[str] = Field(None, description='UID represents the file UID.')


class Config2(BaseModel):
    ConfigID: Optional[str] = Field(
        None,
        description="ConfigID represents the ID of the specific config that we're referencing.",
    )
    ConfigName: Optional[str] = Field(
        None,
        description='ConfigName is the name of the config that this references, but this is just provided for\nlookup/display purposes. The config in the reference will be identified by its ID.\n',
    )
    File_1: Optional[File] = Field(
        None,
        alias='File',
        description='File represents a specific target that is backed by a file.',
    )


class DNSConfig(BaseModel):
    Nameservers: Optional[List[str]] = Field(
        None, description='The IP addresses of the name servers.'
    )
    Options: Optional[List[str]] = Field(
        None,
        description='A list of internal resolver variables to be modified (e.g., `debug`, `ndots:3`, etc.).',
    )
    Search: Optional[List[str]] = Field(
        None, description='A search list for host-name lookup.'
    )


class CredentialSpec(BaseModel):
    File: Optional[str] = Field(
        None,
        description='Load credential spec from this file. The file is read by the daemon, and must be present in the\n`CredentialSpecs` subdirectory in the docker data directory, which defaults to\n`C:\\ProgramData\\Docker\\` on Windows.\n\nFor example, specifying `spec.json` loads `C:\\ProgramData\\Docker\\CredentialSpecs\\spec.json`.\n\n<p><br /></p>\n\n> **Note**: `CredentialSpec.File` and `CredentialSpec.Registry` are mutually exclusive.\n',
    )
    Registry: Optional[str] = Field(
        None,
        description='Load credential spec from this value in the Windows registry. The specified registry value must be\nlocated in:\n\n`HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Virtualization\\Containers\\CredentialSpecs`\n\n<p><br /></p>\n\n\n> **Note**: `CredentialSpec.File` and `CredentialSpec.Registry` are mutually exclusive.\n',
    )


class SELinuxContext(BaseModel):
    Disable: Optional[bool] = Field(None, description='Disable SELinux')
    Level: Optional[str] = Field(None, description='SELinux level label')
    Role: Optional[str] = Field(None, description='SELinux role label')
    Type: Optional[str] = Field(None, description='SELinux type label')
    User: Optional[str] = Field(None, description='SELinux user label')


class Privileges(BaseModel):
    CredentialSpec_1: Optional[CredentialSpec] = Field(
        None,
        alias='CredentialSpec',
        description='CredentialSpec for managed service account (Windows only)',
    )
    SELinuxContext_1: Optional[SELinuxContext] = Field(
        None, alias='SELinuxContext', description='SELinux labels of the container'
    )


class Secret1(BaseModel):
    File_1: Optional[File] = Field(
        None,
        alias='File',
        description='File represents a specific target that is backed by a file.',
    )
    SecretID: Optional[str] = Field(
        None,
        description="SecretID represents the ID of the specific secret that we're referencing.",
    )
    SecretName: Optional[str] = Field(
        None,
        description='SecretName is the name of the secret that this references, but this is just provided for\nlookup/display purposes. The secret in the reference will be identified by its ID.\n',
    )


class ContainerSpec(BaseModel):
    Args: Optional[List[str]] = Field(None, description='Arguments to the command.')
    Command: Optional[List[str]] = Field(
        None, description='The command to be run in the image.'
    )
    Configs: Optional[List[Config2]] = Field(
        None,
        description='Configs contains references to zero or more configs that will be exposed to the service.',
    )
    DNSConfig_1: Optional[DNSConfig] = Field(
        None,
        alias='DNSConfig',
        description='Specification for DNS related configurations in resolver configuration file (`resolv.conf`).',
    )
    Dir: Optional[str] = Field(
        None, description='The working directory for commands to run in.'
    )
    Env: Optional[List[str]] = Field(
        None, description='A list of environment variables in the form `VAR=value`.'
    )
    Groups: Optional[List[str]] = Field(
        None,
        description='A list of additional groups that the container process will run as.',
    )
    HealthCheck: Optional[HealthConfig] = None
    Hostname: Optional[str] = Field(
        None,
        description='The hostname to use for the container, as a valid RFC 1123 hostname.',
    )
    Hosts: Optional[List[str]] = Field(
        None,
        description="A list of hostname/IP mappings to add to the container's `hosts`\nfile. The format of extra hosts is specified in the\n[hosts(5)](http://man7.org/linux/man-pages/man5/hosts.5.html)\nman page:\n\n    IP_address canonical_hostname [aliases...]\n",
    )
    Image: Optional[str] = Field(
        None, description='The image name to use for the container'
    )
    Labels: Optional[Dict[str, str]] = Field(
        None, description='User-defined key/value data.'
    )
    Mounts: Optional[List[Mount]] = Field(
        None,
        description='Specification for mounts to be added to containers created as part of the service.',
    )
    OpenStdin: Optional[bool] = Field(None, description='Open `stdin`')
    Privileges_1: Optional[Privileges] = Field(
        None, alias='Privileges', description='Security options for the container'
    )
    ReadOnly: Optional[bool] = Field(
        None, description="Mount the container's root filesystem as read only."
    )
    Secrets: Optional[List[Secret1]] = Field(
        None,
        description='Secrets contains references to zero or more secrets that will be exposed to the service.',
    )
    StopGracePeriod: Optional[int] = Field(
        None,
        description='Amount of time to wait for the container to terminate before forcefully killing it.',
    )
    StopSignal: Optional[str] = Field(None, description='Signal to stop the container.')
    TTY: Optional[bool] = Field(
        None, description='Whether a pseudo-TTY should be allocated.'
    )
    User: Optional[str] = Field(None, description='The user inside the container.')


class LogDriver1(BaseModel):
    Name: Optional[str] = None
    Options: Optional[Dict[str, str]] = None


class Spread(BaseModel):
    SpreadDescriptor: Optional[str] = Field(
        None, description='label descriptor, such as engine.labels.az'
    )


class Preference(BaseModel):
    Spread_1: Optional[Spread] = Field(None, alias='Spread')


class Placement(BaseModel):
    Constraints: Optional[List[str]] = Field(
        None,
        description='An array of constraints.',
        examples=[
            [
                'node.hostname!=node3.corp.example.com',
                'node.role!=manager',
                'node.labels.type==production',
            ]
        ],
    )
    Platforms: Optional[List[Platform]] = Field(
        None,
        description="Platforms stores all the platforms that the service's image can\nrun on. This field is used in the platform filter for scheduling.\nIf empty, then the platform filter is off, meaning there are no\nscheduling restrictions.\n",
    )
    Preferences: Optional[List[Preference]] = Field(
        None,
        description='Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence.',
        examples=[
            [
                {'Spread': {'SpreadDescriptor': 'node.labels.datacenter'}},
                {'Spread': {'SpreadDescriptor': 'node.labels.rack'}},
            ]
        ],
    )


class PluginPrivilegeItem(BaseModel):
    Description: Optional[str] = None
    Name: Optional[str] = None
    Value: Optional[List[str]] = None


class PluginSpec(BaseModel):
    Disabled: Optional[bool] = Field(
        None, description='Disable the plugin once scheduled.'
    )
    Name: Optional[str] = Field(
        None, description="The name or 'alias' to use for the plugin."
    )
    PluginPrivilege: Optional[List[PluginPrivilegeItem]] = None
    Remote: Optional[str] = Field(
        None, description='The plugin image reference to use.'
    )


class Resources1(BaseModel):
    Limits: Optional[ResourceObject] = None
    Reservation: Optional[ResourceObject] = None


class Condition(Enum):
    none = 'none'
    on_failure = 'on-failure'
    any = 'any'


class RestartPolicy1(BaseModel):
    Condition_1: Optional[Condition] = Field(
        None, alias='Condition', description='Condition for restart.'
    )
    Delay: Optional[int] = Field(None, description='Delay between restart attempts.')
    MaxAttempts: Optional[int] = Field(
        0,
        description='Maximum attempts to restart a given container before giving up (default value is 0, which is ignored).',
    )
    Window: Optional[int] = Field(
        0,
        description='Windows is the time window used to evaluate the restart policy (default value is 0, which is unbounded).',
    )


class TaskSpec(BaseModel):
    ContainerSpec_1: Optional[ContainerSpec] = Field(
        None,
        alias='ContainerSpec',
        description='Invalid when specified with `PluginSpec`.',
    )
    ForceUpdate: Optional[int] = Field(
        None,
        description='A counter that triggers an update even if no relevant parameters have been changed.',
    )
    LogDriver: Optional[LogDriver1] = Field(
        None,
        description='Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified.',
    )
    Networks: Optional[List[Network2]] = None
    Placement_1: Optional[Placement] = Field(None, alias='Placement')
    PluginSpec_1: Optional[PluginSpec] = Field(
        None,
        alias='PluginSpec',
        description='Invalid when specified with `ContainerSpec`. *(Experimental release only.)*',
    )
    Resources: Optional[Resources1] = Field(
        None,
        description='Resource requirements which apply to each individual container created as part of the service.',
    )
    RestartPolicy: Optional[RestartPolicy1] = Field(
        None,
        description='Specification for the restart policy which applies to containers created as part of this service.',
    )
    Runtime: Optional[str] = Field(
        None,
        description='Runtime is the type of runtime specified for the task executor.',
    )


class TaskState(Enum):
    new = 'new'
    allocated = 'allocated'
    pending = 'pending'
    assigned = 'assigned'
    accepted = 'accepted'
    preparing = 'preparing'
    ready = 'ready'
    starting = 'starting'
    running = 'running'
    complete = 'complete'
    shutdown = 'shutdown'
    failed = 'failed'
    rejected = 'rejected'


class ThrottleDevice(BaseModel):
    Path: Optional[str] = Field(None, description='Device path')
    Rate: Optional[conint(ge=0)] = Field(None, description='Rate')


class Scope(Enum):
    local = 'local'
    global_ = 'global'


class UsageData(BaseModel):
    RefCount: int = Field(
        ...,
        description='The number of containers referencing this volume. This field\nis set to `-1` if the reference-count is not available.\n',
    )
    Size: int = Field(
        ...,
        description='Amount of disk space used by the volume (in bytes). This information\nis only available for volumes created with the `"local"` volume\ndriver. For volumes created with other volume drivers, this field\nis set to `-1` ("not available")\n',
    )


class Volume(BaseModel):
    CreatedAt: Optional[str] = Field(
        None, description='Date/Time the volume was created.'
    )
    Driver: str = Field(
        ..., description='Name of the volume driver used by the volume.'
    )
    Labels: Dict[str, str] = Field(..., description='User-defined key/value metadata.')
    Mountpoint: str = Field(..., description='Mount path of the volume on the host.')
    Name: str = Field(..., description='Name of the volume.')
    Options: Dict[str, str] = Field(
        ..., description='The driver specific options used when creating the volume.'
    )
    Scope_1: Scope = Field(
        ...,
        alias='Scope',
        description='The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.',
    )
    Status: Optional[Dict[str, Dict[str, Any]]] = Field(
        None,
        description='Low-level details about the volume, provided by the volume driver.\nDetails are returned as a map with key/value pairs:\n`{"key":"value","key2":"value2"}`.\n\nThe `Status` field is optional, and is omitted if the volume driver\ndoes not support this feature.\n',
    )
    UsageData_1: Optional[UsageData] = Field(
        None,
        alias='UsageData',
        description='Usage details about the volume. This information is used by the\n`GET /system/df` endpoint, and omitted in other endpoints.\n',
    )


class AuthPostResponse(BaseModel):
    IdentityToken: Optional[str] = Field(
        None,
        description='An opaque token used to authenticate a user after a successful login',
    )
    Status: str = Field(..., description='The status of the authentication')


class ContentType(Enum):
    application_x_tar = 'application/x-tar'


class BuildPrunePostResponse(BaseModel):
    SpaceReclaimed: Optional[int] = Field(
        None, description='Disk space reclaimed in bytes'
    )


ConfigsCreatePostRequest = ConfigSpec


class ConfigsCreatePostResponse(BaseModel):
    ID: Optional[str] = Field(None, description='The ID of the created config.')


class NetworkingConfig(BaseModel):
    EndpointsConfig: Optional[Dict[str, EndpointSettings]] = Field(
        None,
        description='A mapping of network name to endpoint configuration for that network.',
    )


class ContainersCreatePostResponse(BaseModel):
    Id: str = Field(..., description='The ID of the created container')
    Warnings: List[str] = Field(
        ..., description='Warnings encountered when creating the container'
    )


class ContainersPrunePostResponse(BaseModel):
    ContainersDeleted: Optional[List[str]] = Field(
        None, description='Container IDs that were deleted'
    )
    SpaceReclaimed: Optional[int] = Field(
        None, description='Disk space reclaimed in bytes'
    )


class ContainersIdArchiveGetResponse(ErrorResponse):
    message: Optional[str] = Field(
        None,
        description='The error message. Either "must specify path parameter" (path cannot be empty) or "not a directory" (path was asserted to be a directory but exists as a file).',
    )


class ContainersIdArchiveHeadResponse(ErrorResponse):
    message: Optional[str] = Field(
        None,
        description='The error message. Either "must specify path parameter" (path cannot be empty) or "not a directory" (path was asserted to be a directory but exists as a file).',
    )


class Kind(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2


class ContainersIdChangesGetResponseItem(BaseModel):
    Kind_1: Kind = Field(..., alias='Kind', description='Kind of change')
    Path: str = Field(..., description='Path to file that has changed')


class ContainersIdChangesGetResponse(
    RootModel[List[ContainersIdChangesGetResponseItem]]
):
    root: List[ContainersIdChangesGetResponseItem]


class ContainersIdExecPostRequest(BaseModel):
    AttachStderr: Optional[bool] = Field(
        None, description='Attach to `stderr` of the exec command.'
    )
    AttachStdin: Optional[bool] = Field(
        None, description='Attach to `stdin` of the exec command.'
    )
    AttachStdout: Optional[bool] = Field(
        None, description='Attach to `stdout` of the exec command.'
    )
    Cmd: Optional[List[str]] = Field(
        None, description='Command to run, as a string or array of strings.'
    )
    DetachKeys: Optional[str] = Field(
        None,
        description='Override the key sequence for detaching a container. Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`.',
    )
    Env: Optional[List[str]] = Field(
        None,
        description='A list of environment variables in the form `["VAR=value", ...]`.',
    )
    Privileged: Optional[bool] = Field(
        False, description='Runs the exec process with extended privileges.'
    )
    Tty: Optional[bool] = Field(None, description='Allocate a pseudo-TTY.')
    User: Optional[str] = Field(
        None,
        description='The user, and optionally, group to run the exec process inside the container. Format is one of: `user`, `user:group`, `uid`, or `uid:gid`.',
    )


class Status1(Enum):
    created = 'created'
    running = 'running'
    paused = 'paused'
    restarting = 'restarting'
    removing = 'removing'
    exited = 'exited'
    dead = 'dead'


class State1(BaseModel):
    Dead: Optional[bool] = None
    Error: Optional[str] = None
    ExitCode: Optional[int] = Field(
        None, description='The last exit code of this container'
    )
    FinishedAt: Optional[str] = Field(
        None, description='The time when this container last exited.'
    )
    OOMKilled: Optional[bool] = Field(
        None,
        description='Whether this container has been killed because it ran out of memory.',
    )
    Paused: Optional[bool] = Field(
        None, description='Whether this container is paused.'
    )
    Pid: Optional[int] = Field(None, description='The process ID of this container')
    Restarting: Optional[bool] = Field(
        None, description='Whether this container is restarting.'
    )
    Running: Optional[bool] = Field(
        None,
        description='Whether this container is running.\n\nNote that a running container can be _paused_. The `Running` and `Paused`\nbooleans are not mutually exclusive:\n\nWhen pausing a container (on Linux), the cgroups freezer is used to suspend\nall processes in the container. Freezing the process requires the process to\nbe running. As a result, paused containers are both `Running` _and_ `Paused`.\n\nUse the `Status` field instead to determine if a container\'s state is "running".\n',
    )
    StartedAt: Optional[str] = Field(
        None, description='The time when this container was last started.'
    )
    Status: Optional[Status1] = Field(
        None,
        description='The status of the container. For example, `"running"` or `"exited"`.\n',
    )


class ContainersIdStatsGetResponse(BaseModel):
    pass


class ContainersIdTopGetResponse(BaseModel):
    Processes: Optional[List[List[str]]] = Field(
        None,
        description='Each process running in the container, where each is process is an array of values corresponding to the titles',
    )
    Titles: Optional[List[str]] = Field(None, description='The ps column titles')


class ContainersIdUpdatePostResponse(BaseModel):
    Warnings: Optional[List[str]] = None


class ContainersIdWaitPostResponse(BaseModel):
    StatusCode: int = Field(..., description='Exit code of the container')


class Descriptor(BaseModel):
    Digest: Optional[str] = None
    MediaType: Optional[str] = None
    Size: Optional[int] = None
    URLs: Optional[List[str]] = None


class Platform1(BaseModel):
    Architecture: Optional[str] = None
    Features: Optional[List[str]] = None
    OS: Optional[str] = None
    OSFeatures: Optional[List[str]] = None
    OSVersion: Optional[str] = None
    Variant: Optional[str] = None


class DistributionNameJsonGetResponse(BaseModel):
    Descriptor_1: Descriptor = Field(
        ...,
        alias='Descriptor',
        description='A descriptor struct containing digest, media type, and size',
    )
    Platforms: List[Platform1] = Field(
        ..., description='An array containing all platforms supported by the image'
    )


class Actor(BaseModel):
    Attributes: Optional[Dict[str, str]] = Field(
        None,
        description='Various key/value attributes of the object, depending on its type',
    )
    ID: Optional[str] = Field(
        None, description='The ID of the object emitting the event'
    )


class EventsGetResponse(BaseModel):
    Action: Optional[str] = Field(None, description='The type of event')
    Actor_1: Optional[Actor] = Field(None, alias='Actor')
    Type: Optional[str] = Field(
        None, description='The type of object emitting the event'
    )
    time: Optional[int] = Field(None, description='Timestamp of event')
    timeNano: Optional[int] = Field(
        None, description='Timestamp of event, with nanosecond accuracy'
    )


class ExecIdJsonGetResponse(BaseModel):
    ContainerID: Optional[str] = None
    ExitCode: Optional[int] = None
    ID: Optional[str] = None
    OpenStderr: Optional[bool] = None
    OpenStdin: Optional[bool] = None
    OpenStdout: Optional[bool] = None
    Pid: Optional[int] = Field(
        None, description='The system process ID for the exec process.'
    )
    ProcessConfig_1: Optional[ProcessConfig] = Field(None, alias='ProcessConfig')
    Running: Optional[bool] = None


class ExecIdStartPostRequest(BaseModel):
    Detach: Optional[bool] = Field(None, description='Detach from the command.')
    Tty: Optional[bool] = Field(None, description='Allocate a pseudo-TTY.')


class Names(RootModel[List[str]]):
    root: List[str]


class ImagesJsonGetResponse(RootModel[List[ImageSummary]]):
    root: List[ImageSummary]


class ImagesPrunePostResponse(BaseModel):
    ImagesDeleted: Optional[List[ImageDeleteResponseItem]] = Field(
        None, description='Images that were deleted'
    )
    SpaceReclaimed: Optional[int] = Field(
        None, description='Disk space reclaimed in bytes'
    )


class ImagesSearchGetResponseItem(BaseModel):
    description: Optional[str] = None
    is_automated: Optional[bool] = None
    is_official: Optional[bool] = None
    name: Optional[str] = None
    star_count: Optional[int] = None


class ImagesSearchGetResponse(RootModel[List[ImagesSearchGetResponseItem]]):
    root: List[ImagesSearchGetResponseItem]


class ImagesNameDeleteResponse(RootModel[List[ImageDeleteResponseItem]]):
    root: List[ImageDeleteResponseItem]


class ImagesNameHistoryGetResponseItem(BaseModel):
    Comment: str
    Created: int
    CreatedBy: str
    Id: str
    Size: int
    Tags: List[str]


class ImagesNameHistoryGetResponse(RootModel[List[ImagesNameHistoryGetResponseItem]]):
    root: List[ImagesNameHistoryGetResponseItem]


class NetworksCreatePostRequest(BaseModel):
    Attachable: Optional[bool] = Field(
        None,
        description='Globally scoped network is manually attachable by regular containers from workers in swarm mode.',
    )
    CheckDuplicate: Optional[bool] = Field(
        None,
        description='Check for networks with duplicate names. Since Network is primarily keyed based on a random ID and not on the name, and network name is strictly a user-friendly alias to the network which is uniquely identified using ID, there is no guaranteed way to check for duplicates. CheckDuplicate is there to provide a best effort checking of any networks which has the same name but it is not guaranteed to catch all name collisions.',
    )
    Driver: Optional[str] = Field(
        'bridge', description='Name of the network driver plugin to use.'
    )
    EnableIPv6: Optional[bool] = Field(None, description='Enable IPv6 on the network.')
    IPAM_1: Optional[IPAM] = Field(None, alias='IPAM')
    Ingress: Optional[bool] = Field(
        None,
        description='Ingress network is the network which provides the routing-mesh in swarm mode.',
    )
    Internal: Optional[bool] = Field(
        None, description='Restrict external access to the network.'
    )
    Labels: Optional[Dict[str, str]] = Field(
        None, description='User-defined key/value metadata.'
    )
    Name: str = Field(..., description="The network's name.")
    Options: Optional[Dict[str, str]] = Field(
        None, description='Network specific options to be used by the drivers.'
    )


class NetworksCreatePostResponse(BaseModel):
    Id: Optional[str] = Field(None, description='The ID of the created network.')
    Warning: Optional[str] = None


class NetworksPrunePostResponse(BaseModel):
    NetworksDeleted: Optional[List[str]] = Field(
        None, description='Networks that were deleted'
    )


class NetworksIdConnectPostRequest(BaseModel):
    Container: Optional[str] = Field(
        None, description='The ID or name of the container to connect to the network.'
    )
    EndpointConfig: Optional[EndpointSettings] = None


class NetworksIdDisconnectPostRequest(BaseModel):
    Container: Optional[str] = Field(
        None,
        description='The ID or name of the container to disconnect from the network.',
    )
    Force: Optional[bool] = Field(
        None, description='Force the container to disconnect from the network.'
    )


class PluginsPrivilegesGetResponseItem(BaseModel):
    Description: Optional[str] = None
    Name: Optional[str] = None
    Value: Optional[List[str]] = None


class PluginsPrivilegesGetResponse(RootModel[List[PluginsPrivilegesGetResponseItem]]):
    root: List[PluginsPrivilegesGetResponseItem] = Field(
        ...,
        examples=[
            [
                {'Description': '', 'Name': 'network', 'Value': ['host']},
                {'Description': '', 'Name': 'mount', 'Value': ['/data']},
                {
                    'Description': '',
                    'Name': 'device',
                    'Value': ['/dev/cpu_dma_latency'],
                },
            ]
        ],
    )


class PluginsPrivilegesGetResponse1(RootModel[List[PluginsPrivilegesGetResponseItem]]):
    root: List[PluginsPrivilegesGetResponseItem] = Field(
        ...,
        examples=[
            [
                {'Description': '', 'Name': 'network', 'Value': ['host']},
                {'Description': '', 'Name': 'mount', 'Value': ['/data']},
                {
                    'Description': '',
                    'Name': 'device',
                    'Value': ['/dev/cpu_dma_latency'],
                },
            ]
        ],
    )


class PluginsPullPostRequestItem(BaseModel):
    Description: Optional[str] = None
    Name: Optional[str] = None
    Value: Optional[List[str]] = None


class PluginsPullPostRequest(RootModel[List[PluginsPullPostRequestItem]]):
    root: List[PluginsPullPostRequestItem] = Field(
        ...,
        examples=[
            [
                {'Description': '', 'Name': 'network', 'Value': ['host']},
                {'Description': '', 'Name': 'mount', 'Value': ['/data']},
                {
                    'Description': '',
                    'Name': 'device',
                    'Value': ['/dev/cpu_dma_latency'],
                },
            ]
        ],
    )


class PluginsPullPostRequest1(RootModel[List[PluginsPullPostRequestItem]]):
    root: List[PluginsPullPostRequestItem] = Field(
        ...,
        examples=[
            [
                {'Description': '', 'Name': 'network', 'Value': ['host']},
                {'Description': '', 'Name': 'mount', 'Value': ['/data']},
                {
                    'Description': '',
                    'Name': 'device',
                    'Value': ['/dev/cpu_dma_latency'],
                },
            ]
        ],
    )


class PluginsNameSetPostRequest(RootModel[List[str]]):
    root: List[str] = Field(..., examples=[['DEBUG=1']])


class PluginsNameUpgradePostRequestItem(BaseModel):
    Description: Optional[str] = None
    Name: Optional[str] = None
    Value: Optional[List[str]] = None


class PluginsNameUpgradePostRequest(RootModel[List[PluginsNameUpgradePostRequestItem]]):
    root: List[PluginsNameUpgradePostRequestItem] = Field(
        ...,
        examples=[
            [
                {'Description': '', 'Name': 'network', 'Value': ['host']},
                {'Description': '', 'Name': 'mount', 'Value': ['/data']},
                {
                    'Description': '',
                    'Name': 'device',
                    'Value': ['/dev/cpu_dma_latency'],
                },
            ]
        ],
    )


class PluginsNameUpgradePostRequest1(
    RootModel[List[PluginsNameUpgradePostRequestItem]]
):
    root: List[PluginsNameUpgradePostRequestItem] = Field(
        ...,
        examples=[
            [
                {'Description': '', 'Name': 'network', 'Value': ['host']},
                {'Description': '', 'Name': 'mount', 'Value': ['/data']},
                {
                    'Description': '',
                    'Name': 'device',
                    'Value': ['/dev/cpu_dma_latency'],
                },
            ]
        ],
    )


SecretsCreatePostRequest = SecretSpec


class SecretsCreatePostResponse(BaseModel):
    ID: Optional[str] = Field(None, description='The ID of the created secret.')


class ServicesCreatePostResponse(BaseModel):
    ID: Optional[str] = Field(None, description='The ID of the created service.')
    Warning: Optional[str] = Field(None, description='Optional warning message')


class SwarmInitPostRequest(BaseModel):
    AdvertiseAddr: Optional[str] = Field(
        None,
        description='Externally reachable address advertised to other nodes. This can either be an address/port combination in the form `192.168.1.1:4567`, or an interface followed by a port number, like `eth0:4567`. If the port number is omitted, the port number from the listen address is used. If `AdvertiseAddr` is not specified, it will be automatically detected when possible.',
    )
    DataPathAddr: Optional[str] = Field(
        None,
        description='Address or interface to use for data path traffic (format: `<ip|interface>`), for example,  `192.168.1.1`,\nor an interface, like `eth0`. If `DataPathAddr` is unspecified, the same address as `AdvertiseAddr`\nis used.\n\nThe `DataPathAddr` specifies the address that global scope network drivers will publish towards other\nnodes in order to reach the containers running on this node. Using this parameter it is possible to\nseparate the container data traffic from the management traffic of the cluster.\n',
    )
    ForceNewCluster: Optional[bool] = Field(
        None, description='Force creation of a new swarm.'
    )
    ListenAddr: Optional[str] = Field(
        None,
        description='Listen address used for inter-manager communication, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). This can either be an address/port combination in the form `192.168.1.1:4567`, or an interface followed by a port number, like `eth0:4567`. If the port number is omitted, the default swarm listening port is used.',
    )
    Spec: Optional[SwarmSpec] = None


class SwarmJoinPostRequest(BaseModel):
    AdvertiseAddr: Optional[str] = Field(
        None,
        description='Externally reachable address advertised to other nodes. This can either be an address/port combination in the form `192.168.1.1:4567`, or an interface followed by a port number, like `eth0:4567`. If the port number is omitted, the port number from the listen address is used. If `AdvertiseAddr` is not specified, it will be automatically detected when possible.',
    )
    DataPathAddr: Optional[str] = Field(
        None,
        description='Address or interface to use for data path traffic (format: `<ip|interface>`), for example,  `192.168.1.1`,\nor an interface, like `eth0`. If `DataPathAddr` is unspecified, the same address as `AdvertiseAddr`\nis used.\n\nThe `DataPathAddr` specifies the address that global scope network drivers will publish towards other\nnodes in order to reach the containers running on this node. Using this parameter it is possible to\nseparate the container data traffic from the management traffic of the cluster.\n',
    )
    JoinToken: Optional[str] = Field(
        None, description='Secret token for joining this swarm.'
    )
    ListenAddr: Optional[str] = Field(
        None,
        description='Listen address used for inter-manager communication if the node gets promoted to manager, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP).',
    )
    RemoteAddrs: Optional[str] = Field(
        None,
        description='Addresses of manager nodes already participating in the swarm.',
    )


class SwarmUnlockPostRequest(BaseModel):
    UnlockKey: Optional[str] = Field(None, description="The swarm's unlock key.")


class SwarmUnlockkeyGetResponse(BaseModel):
    UnlockKey: Optional[str] = Field(None, description="The swarm's unlock key.")


class VersionGetResponse(BaseModel):
    ApiVersion: Optional[str] = None
    Arch: Optional[str] = None
    BuildTime: Optional[str] = None
    Experimental: Optional[bool] = None
    GitCommit: Optional[str] = None
    GoVersion: Optional[str] = None
    KernelVersion: Optional[str] = None
    MinAPIVersion: Optional[str] = None
    Os: Optional[str] = None
    Version: Optional[str] = None


class VolumesGetResponse(BaseModel):
    Volumes: List[Volume] = Field(..., description='List of volumes')
    Warnings: List[str] = Field(
        ..., description='Warnings that occurred when fetching the list of volumes'
    )


class VolumesCreatePostRequest(BaseModel):
    Driver: Optional[str] = Field(
        'local', description='Name of the volume driver to use.'
    )
    DriverOpts: Optional[Dict[str, str]] = Field(
        None,
        description='A mapping of driver options and values. These options are passed directly to the driver and are driver specific.',
    )
    Labels: Optional[Dict[str, str]] = Field(
        None, description='User-defined key/value metadata.'
    )
    Name: Optional[str] = Field(
        None,
        description="The new volume's name. If not specified, Docker generates a name.",
    )


class VolumesPrunePostResponse(BaseModel):
    SpaceReclaimed: Optional[int] = Field(
        None, description='Disk space reclaimed in bytes'
    )
    VolumesDeleted: Optional[List[str]] = Field(
        None, description='Volumes that were deleted'
    )


class BuildInfo(BaseModel):
    error: Optional[str] = None
    errorDetail: Optional[ErrorDetail] = None
    id: Optional[str] = None
    progress: Optional[str] = None
    progressDetail: Optional[ProgressDetail] = None
    status: Optional[str] = None
    stream: Optional[str] = None


class ClusterInfo(BaseModel):
    CreatedAt: Optional[str] = Field(
        None,
        description='Date and time at which the swarm was initialised in\n[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.\n',
        examples=['2016-08-18T10:44:24.496525531Z'],
    )
    ID: Optional[str] = Field(
        None, description='The ID of the swarm.', examples=['abajmipo7b4xz5ip2nrla6b11']
    )
    RootRotationInProgress: Optional[bool] = Field(
        None,
        description='Whether there is currently a root CA rotation in progress for the swarm',
        examples=[False],
    )
    Spec: Optional[SwarmSpec] = None
    TLSInfo_1: Optional[TLSInfo] = Field(None, alias='TLSInfo')
    UpdatedAt: Optional[str] = Field(
        None,
        description='Date and time at which the swarm was last updated in\n[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.\n',
        examples=['2017-08-09T07:09:37.632105588Z'],
    )
    Version: Optional[ObjectVersion] = None


class Config(BaseModel):
    CreatedAt: Optional[str] = None
    ID: Optional[str] = None
    Spec: Optional[ConfigSpec] = None
    UpdatedAt: Optional[str] = None
    Version: Optional[ObjectVersion] = None


class ContainerConfig(BaseModel):
    ArgsEscaped: Optional[bool] = Field(
        None, description='Command is already escaped (Windows only)'
    )
    AttachStderr: Optional[bool] = Field(
        True, description='Whether to attach to `stderr`.'
    )
    AttachStdin: Optional[bool] = Field(
        False, description='Whether to attach to `stdin`.'
    )
    AttachStdout: Optional[bool] = Field(
        True, description='Whether to attach to `stdout`.'
    )
    Cmd: Optional[List[str]] = Field(
        None, description='Command to run specified as a string or an array of strings.'
    )
    Domainname: Optional[str] = Field(
        None, description='The domain name to use for the container.'
    )
    Entrypoint: Optional[List[str]] = Field(
        None,
        description='The entry point for the container as a string or an array of strings.\n\nIf the array consists of exactly one empty string (`[""]`) then the entry point is reset to system default (i.e., the entry point used by docker when there is no `ENTRYPOINT` instruction in the `Dockerfile`).\n',
    )
    Env: Optional[List[str]] = Field(
        None,
        description='A list of environment variables to set inside the container in the form `["VAR=value", ...]`. A variable without `=` is removed from the environment, rather than to have an empty value.\n',
    )
    ExposedPorts: Optional[Dict[str, Dict[str, Any]]] = Field(
        None,
        description='An object mapping ports to an empty object in the form:\n\n`{"<port>/<tcp|udp>": {}}`\n',
    )
    Healthcheck: Optional[HealthConfig] = None
    Hostname: Optional[str] = Field(
        None,
        description='The hostname to use for the container, as a valid RFC 1123 hostname.',
    )
    Image: Optional[str] = Field(
        None, description='The name of the image to use when creating the container'
    )
    Labels: Optional[Dict[str, str]] = Field(
        None, description='User-defined key/value metadata.'
    )
    MacAddress: Optional[str] = Field(None, description='MAC address of the container.')
    NetworkDisabled: Optional[bool] = Field(
        None, description='Disable networking for the container.'
    )
    OnBuild: Optional[List[str]] = Field(
        None,
        description="`ONBUILD` metadata that were defined in the image's `Dockerfile`.",
    )
    OpenStdin: Optional[bool] = Field(False, description='Open `stdin`')
    Shell: Optional[List[str]] = Field(
        None, description='Shell for when `RUN`, `CMD`, and `ENTRYPOINT` uses a shell.'
    )
    StdinOnce: Optional[bool] = Field(
        False, description='Close `stdin` after one attached client disconnects'
    )
    StopSignal: Optional[str] = Field(
        'SIGTERM',
        description='Signal to stop a container as a string or unsigned integer.',
    )
    StopTimeout: Optional[int] = Field(
        10, description='Timeout to stop a container in seconds.'
    )
    Tty: Optional[bool] = Field(
        False,
        description='Attach standard streams to a TTY, including `stdin` if it is not closed.',
    )
    User: Optional[str] = Field(
        None, description='The user that commands are run as inside the container.'
    )
    Volumes_1: Optional[Volumes] = Field(
        None,
        alias='Volumes',
        description='An object mapping mount point paths inside the container to empty objects.',
    )
    WorkingDir: Optional[str] = Field(
        None, description='The working directory for commands to run in.'
    )


class NetworkSettings(BaseModel):
    Networks: Optional[Dict[str, EndpointSettings]] = None


class ContainerSummaryItem(BaseModel):
    Command: Optional[str] = Field(
        None, description='Command to run when starting the container'
    )
    Created: Optional[int] = Field(None, description='When the container was created')
    HostConfig_1: Optional[HostConfig] = Field(None, alias='HostConfig')
    Id: Optional[str] = Field(None, description='The ID of this container')
    Image: Optional[str] = Field(
        None, description='The name of the image used when creating this container'
    )
    ImageID: Optional[str] = Field(
        None, description='The ID of the image that this container was created from'
    )
    Labels: Optional[Dict[str, str]] = Field(
        None, description='User-defined key/value metadata.'
    )
    Mounts: Optional[List[Mount]] = None
    Names: Optional[List[str]] = Field(
        None, description='The names that this container has been given'
    )
    NetworkSettings_1: Optional[NetworkSettings] = Field(
        None,
        alias='NetworkSettings',
        description="A summary of the container's network settings",
    )
    Ports: Optional[List[Port]] = Field(
        None, description='The ports exposed by this container'
    )
    SizeRootFs: Optional[int] = Field(
        None, description='The total size of all the files in this container'
    )
    SizeRw: Optional[int] = Field(
        None,
        description='The size of files that have been created or changed by this container',
    )
    State: Optional[str] = Field(
        None, description='The state of this container (e.g. `Exited`)'
    )
    Status: Optional[str] = Field(
        None,
        description='Additional human-readable status of this container (e.g. `Exit 0`)',
    )


class ContainerSummary(RootModel[List[ContainerSummaryItem]]):
    root: List[ContainerSummaryItem]


class CreateImageInfo(BaseModel):
    error: Optional[str] = None
    progress: Optional[str] = None
    progressDetail: Optional[ProgressDetail] = None
    status: Optional[str] = None


class Image(BaseModel):
    Architecture: str
    Author: str
    Comment: str
    Config: Optional[ContainerConfig] = None
    Container: str
    ContainerConfig_1: Optional[ContainerConfig] = Field(None, alias='ContainerConfig')
    Created: str
    DockerVersion: str
    GraphDriver: GraphDriverData
    Id: str
    Metadata_1: Optional[Metadata] = Field(None, alias='Metadata')
    Os: str
    OsVersion: Optional[str] = None
    Parent: str
    RepoDigests: Optional[List[str]] = None
    RepoTags: Optional[List[str]] = None
    RootFS_1: RootFS = Field(..., alias='RootFS')
    Size: int
    VirtualSize: int


class ManagerStatus(BaseModel):
    Addr: Optional[str] = Field(
        None,
        description='The IP address and port at which the manager is reachable.\n',
        examples=['10.0.0.46:2377'],
    )
    Leader: Optional[bool] = Field(False, examples=[True])
    Reachability_1: Optional[Reachability] = Field(None, alias='Reachability')


class Network(BaseModel):
    Attachable: Optional[bool] = None
    Containers: Optional[Dict[str, NetworkContainer]] = None
    Created: Optional[str] = None
    Driver: Optional[str] = None
    EnableIPv6: Optional[bool] = None
    IPAM_1: Optional[IPAM] = Field(None, alias='IPAM')
    Id: Optional[str] = None
    Ingress: Optional[bool] = None
    Internal: Optional[bool] = None
    Labels: Optional[Dict[str, str]] = None
    Name: Optional[str] = None
    Options: Optional[Dict[str, str]] = None
    Scope: Optional[str] = None


class NetworkSettings1(BaseModel):
    Bridge: Optional[str] = Field(
        None,
        description="Name of the network'a bridge (for example, `docker0`).",
        examples=['docker0'],
    )
    EndpointID: Optional[str] = Field(
        None,
        description='EndpointID uniquely represents a service endpoint in a Sandbox.\n\n<p><br /></p>\n\n> **Deprecated**: This field is only propagated when attached to the\n> default "bridge" network. Use the information from the "bridge"\n> network inside the `Networks` map instead, which contains the same\n> information. This field was deprecated in Docker 1.9 and is scheduled\n> to be removed in Docker 17.12.0\n',
        examples=['b88f5b905aabf2893f3cbc4ee42d1ea7980bbc0a92e2c8922b1e1795298afb0b'],
    )
    Gateway: Optional[str] = Field(
        None,
        description='Gateway address for the default "bridge" network.\n\n<p><br /></p>\n\n> **Deprecated**: This field is only propagated when attached to the\n> default "bridge" network. Use the information from the "bridge"\n> network inside the `Networks` map instead, which contains the same\n> information. This field was deprecated in Docker 1.9 and is scheduled\n> to be removed in Docker 17.12.0\n',
        examples=['172.17.0.1'],
    )
    GlobalIPv6Address: Optional[str] = Field(
        None,
        description='Global IPv6 address for the default "bridge" network.\n\n<p><br /></p>\n\n> **Deprecated**: This field is only propagated when attached to the\n> default "bridge" network. Use the information from the "bridge"\n> network inside the `Networks` map instead, which contains the same\n> information. This field was deprecated in Docker 1.9 and is scheduled\n> to be removed in Docker 17.12.0\n',
        examples=['2001:db8::5689'],
    )
    GlobalIPv6PrefixLen: Optional[int] = Field(
        None,
        description='Mask length of the global IPv6 address.\n\n<p><br /></p>\n\n> **Deprecated**: This field is only propagated when attached to the\n> default "bridge" network. Use the information from the "bridge"\n> network inside the `Networks` map instead, which contains the same\n> information. This field was deprecated in Docker 1.9 and is scheduled\n> to be removed in Docker 17.12.0\n',
        examples=[64],
    )
    HairpinMode: Optional[bool] = Field(
        None,
        description='Indicates if hairpin NAT should be enabled on the virtual interface.\n',
        examples=[False],
    )
    IPAddress: Optional[str] = Field(
        None,
        description='IPv4 address for the default "bridge" network.\n\n<p><br /></p>\n\n> **Deprecated**: This field is only propagated when attached to the\n> default "bridge" network. Use the information from the "bridge"\n> network inside the `Networks` map instead, which contains the same\n> information. This field was deprecated in Docker 1.9 and is scheduled\n> to be removed in Docker 17.12.0\n',
        examples=['172.17.0.4'],
    )
    IPPrefixLen: Optional[int] = Field(
        None,
        description='Mask length of the IPv4 address.\n\n<p><br /></p>\n\n> **Deprecated**: This field is only propagated when attached to the\n> default "bridge" network. Use the information from the "bridge"\n> network inside the `Networks` map instead, which contains the same\n> information. This field was deprecated in Docker 1.9 and is scheduled\n> to be removed in Docker 17.12.0\n',
        examples=[16],
    )
    IPv6Gateway: Optional[str] = Field(
        None,
        description='IPv6 gateway address for this network.\n\n<p><br /></p>\n\n> **Deprecated**: This field is only propagated when attached to the\n> default "bridge" network. Use the information from the "bridge"\n> network inside the `Networks` map instead, which contains the same\n> information. This field was deprecated in Docker 1.9 and is scheduled\n> to be removed in Docker 17.12.0\n',
        examples=['2001:db8:2::100'],
    )
    LinkLocalIPv6Address: Optional[str] = Field(
        None,
        description='IPv6 unicast address using the link-local prefix.',
        examples=['fe80::42:acff:fe11:1'],
    )
    LinkLocalIPv6PrefixLen: Optional[int] = Field(
        None, description='Prefix length of the IPv6 unicast address.', examples=['64']
    )
    MacAddress: Optional[str] = Field(
        None,
        description='MAC address for the container on the default "bridge" network.\n\n<p><br /></p>\n\n> **Deprecated**: This field is only propagated when attached to the\n> default "bridge" network. Use the information from the "bridge"\n> network inside the `Networks` map instead, which contains the same\n> information. This field was deprecated in Docker 1.9 and is scheduled\n> to be removed in Docker 17.12.0\n',
        examples=['02:42:ac:11:00:04'],
    )
    Networks: Optional[Dict[str, EndpointSettings]] = Field(
        None,
        description='Information about all networks that the container is connected to.\n',
    )
    Ports: Optional[PortMap] = None
    SandboxID: Optional[str] = Field(
        None,
        description="SandboxID uniquely represents a container's network stack.",
        examples=['9d12daf2c33f5959c8bf90aa513e4f65b561738661003029ec84830cd503a0c3'],
    )
    SandboxKey: Optional[str] = Field(
        None,
        description='SandboxKey identifies the sandbox',
        examples=['/var/run/docker/netns/8ab54b426c38'],
    )
    SecondaryIPAddresses: Optional[List[Address]] = Field(None, description='')
    SecondaryIPv6Addresses: Optional[List[Address]] = Field(None, description='')


class NodeDescription(BaseModel):
    Engine: Optional[EngineDescription] = None
    Hostname: Optional[str] = Field(None, examples=['bf3067039e47'])
    Platform_1: Optional[Platform] = Field(None, alias='Platform')
    Resources: Optional[ResourceObject] = None
    TLSInfo_1: Optional[TLSInfo] = Field(None, alias='TLSInfo')


class Interface(BaseModel):
    Socket: str = Field(..., examples=['plugins.sock'])
    Types: List[PluginInterfaceType] = Field(
        ..., examples=[['docker.volumedriver/1.0']]
    )


class Linux(BaseModel):
    AllowAllDevices: bool = Field(..., examples=[False])
    Capabilities: List[str] = Field(..., examples=[['CAP_SYS_ADMIN', 'CAP_SYSLOG']])
    Devices: List[PluginDevice]


class Config1(BaseModel):
    Args_1: Args = Field(..., alias='Args')
    Description: str = Field(..., examples=['A sample volume plugin for Docker'])
    DockerVersion: Optional[str] = Field(
        None,
        description='Docker Version used to create the plugin',
        examples=['17.06.0-ce'],
    )
    Documentation: str = Field(
        ..., examples=['https://docs.docker.com/engine/extend/plugins/']
    )
    Entrypoint: List[str] = Field(
        ..., examples=[['/usr/bin/sample-volume-plugin', '/data']]
    )
    Env: List[PluginEnv] = Field(
        ...,
        examples=[
            [
                {
                    'Description': 'If set, prints debug messages',
                    'Name': 'DEBUG',
                    'Settable': None,
                    'Value': '0',
                }
            ]
        ],
    )
    Interface_1: Interface = Field(
        ...,
        alias='Interface',
        description='The interface between Docker and the plugin',
    )
    IpcHost: bool = Field(..., examples=[False])
    Linux_1: Linux = Field(..., alias='Linux')
    Mounts: List[PluginMount]
    Network: Network1
    PidHost: bool = Field(..., examples=[False])
    PropagatedMount: str = Field(..., examples=['/mnt/volumes'])
    User_1: Optional[User] = Field(None, alias='User')
    WorkDir: str = Field(..., examples=['/bin/'])
    rootfs: Optional[Rootfs] = None


class Settings(BaseModel):
    Args: List[str]
    Devices: List[PluginDevice]
    Env: List[str] = Field(..., examples=[['DEBUG=0']])
    Mounts: List[PluginMount]


class Plugin1(BaseModel):
    Config: Config1 = Field(..., description='The config of a plugin.')
    Enabled: bool = Field(
        ...,
        description='True if the plugin is running. False if the plugin is not running, only installed.',
        examples=[True],
    )
    Id: Optional[str] = Field(
        None,
        examples=['5724e2c8652da337ab2eedd19fc6fc0ec908e4bd907c7421bf6a8dfc70c4c078'],
    )
    Name: str = Field(..., examples=['tiborvass/sample-volume-plugin'])
    PluginReference: Optional[str] = Field(
        None,
        description='plugin remote reference used to push/pull the plugin',
        examples=['localhost:5000/tiborvass/sample-volume-plugin:latest'],
    )
    Settings_1: Settings = Field(
        ..., alias='Settings', description='Settings that can be modified by users.'
    )


class Resources(BaseModel):
    BlkioDeviceReadBps: Optional[List[ThrottleDevice]] = Field(
        None,
        description='Limit read rate (bytes per second) from a device, in the form `[{"Path": "device_path", "Rate": rate}]`.\n',
    )
    BlkioDeviceReadIOps: Optional[List[ThrottleDevice]] = Field(
        None,
        description='Limit read rate (IO per second) from a device, in the form `[{"Path": "device_path", "Rate": rate}]`.\n',
    )
    BlkioDeviceWriteBps: Optional[List[ThrottleDevice]] = Field(
        None,
        description='Limit write rate (bytes per second) to a device, in the form `[{"Path": "device_path", "Rate": rate}]`.\n',
    )
    BlkioDeviceWriteIOps: Optional[List[ThrottleDevice]] = Field(
        None,
        description='Limit write rate (IO per second) to a device, in the form `[{"Path": "device_path", "Rate": rate}]`.\n',
    )
    BlkioWeight: Optional[conint(ge=0, le=1000)] = Field(
        None, description='Block IO weight (relative weight).'
    )
    BlkioWeightDevice: Optional[List[BlkioWeightDeviceItem]] = Field(
        None,
        description='Block IO weight (relative device weight) in the form `[{"Path": "device_path", "Weight": weight}]`.\n',
    )
    CgroupParent: Optional[str] = Field(
        None,
        description="Path to `cgroups` under which the container's `cgroup` is created. If the path is not absolute, the path is considered to be relative to the `cgroups` path of the init process. Cgroups are created if they do not already exist.",
    )
    CpuCount: Optional[int] = Field(
        None,
        description='The number of usable CPUs (Windows only).\n\nOn Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is `CPUCount` first, then `CPUShares`, and `CPUPercent` last.\n',
    )
    CpuPercent: Optional[int] = Field(
        None,
        description='The usable percentage of the available CPUs (Windows only).\n\nOn Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is `CPUCount` first, then `CPUShares`, and `CPUPercent` last.\n',
    )
    CpuPeriod: Optional[int] = Field(
        None, description='The length of a CPU period in microseconds.'
    )
    CpuQuota: Optional[int] = Field(
        None,
        description='Microseconds of CPU time that the container can get in a CPU period.',
    )
    CpuRealtimePeriod: Optional[int] = Field(
        None,
        description='The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.',
    )
    CpuRealtimeRuntime: Optional[int] = Field(
        None,
        description='The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.',
    )
    CpuShares: Optional[int] = Field(
        None,
        description="An integer value representing this container's relative CPU weight versus other containers.",
    )
    CpusetCpus: Optional[str] = Field(
        None,
        description='CPUs in which to allow execution (e.g., `0-3`, `0,1`)',
        examples=['0-3'],
    )
    CpusetMems: Optional[str] = Field(
        None,
        description='Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.',
    )
    DeviceCgroupRules: Optional[List[str]] = Field(
        None, description='a list of cgroup rules to apply to the container'
    )
    Devices: Optional[List[DeviceMapping]] = Field(
        None, description='A list of devices to add to the container.'
    )
    DiskQuota: Optional[int] = Field(None, description='Disk limit (in bytes).')
    IOMaximumBandwidth: Optional[int] = Field(
        None,
        description='Maximum IO in bytes per second for the container system drive (Windows only)',
    )
    IOMaximumIOps: Optional[int] = Field(
        None, description='Maximum IOps for the container system drive (Windows only)'
    )
    KernelMemory: Optional[int] = Field(
        None, description='Kernel memory limit in bytes.'
    )
    Memory: Optional[int] = Field(0, description='Memory limit in bytes.')
    MemoryReservation: Optional[int] = Field(
        None, description='Memory soft limit in bytes.'
    )
    MemorySwap: Optional[int] = Field(
        None,
        description='Total memory limit (memory + swap). Set as `-1` to enable unlimited swap.',
    )
    MemorySwappiness: Optional[conint(ge=0, le=100)] = Field(
        None,
        description="Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.",
    )
    NanoCPUs: Optional[int] = Field(
        None, description='CPU quota in units of 10<sup>-9</sup> CPUs.'
    )
    OomKillDisable: Optional[bool] = Field(
        None, description='Disable OOM Killer for the container.'
    )
    PidsLimit: Optional[int] = Field(
        None, description="Tune a container's pids limit. Set -1 for unlimited."
    )
    Ulimits: Optional[List[Ulimit]] = Field(
        None,
        description='A list of resource limits to set in the container. For example: `{"Name": "nofile", "Soft": 1024, "Hard": 2048}`"\n',
    )


class Secret(BaseModel):
    CreatedAt: Optional[str] = Field(None, examples=['2017-07-20T13:55:28.678958722Z'])
    ID: Optional[str] = Field(None, examples=['blt1owaxmitz71s9v5zh81zun'])
    Spec: Optional[SecretSpec] = None
    UpdatedAt: Optional[str] = Field(None, examples=['2017-07-20T13:55:28.678958722Z'])
    Version: Optional[ObjectVersion] = None


class ServiceSpec(BaseModel):
    EndpointSpec_1: Optional[EndpointSpec] = Field(None, alias='EndpointSpec')
    Labels: Optional[Dict[str, str]] = Field(
        None, description='User-defined key/value metadata.'
    )
    Mode: Optional[Mode1] = Field(None, description='Scheduling mode for the service.')
    Name: Optional[str] = Field(None, description='Name of the service.')
    Networks: Optional[List[Network2]] = Field(
        None, description='Array of network names or IDs to attach the service to.'
    )
    RollbackConfig_1: Optional[RollbackConfig] = Field(
        None,
        alias='RollbackConfig',
        description='Specification for the rollback strategy of the service.',
    )
    TaskTemplate: Optional[TaskSpec] = None
    UpdateConfig_1: Optional[UpdateConfig] = Field(
        None,
        alias='UpdateConfig',
        description='Specification for the update strategy of the service.',
    )


class Swarm(ClusterInfo):
    JoinTokens_1: Optional[JoinTokens] = Field(None, alias='JoinTokens')


class SwarmInfo(BaseModel):
    Cluster: Optional[ClusterInfo] = None
    ControlAvailable: Optional[bool] = Field(False, examples=[True])
    Error: Optional[str] = ''
    LocalNodeState_1: Optional[LocalNodeState] = Field('', alias='LocalNodeState')
    Managers: Optional[int] = Field(
        None, description='Total number of managers in the swarm.', examples=[3]
    )
    NodeAddr: Optional[str] = Field(
        '',
        description='IP address at which this node can be reached by other nodes in the\nswarm.\n',
        examples=['10.0.0.46'],
    )
    NodeID: Optional[str] = Field(
        '',
        description='Unique identifier of for this node in the swarm.',
        examples=['k67qz4598weg5unwwffg6z1m1'],
    )
    Nodes: Optional[int] = Field(
        None, description='Total number of nodes in the swarm.', examples=[4]
    )
    RemoteManagers: Optional[List[PeerNode]] = Field(
        None,
        description="List of ID's and addresses of other managers in the swarm.\n",
        examples=[
            [
                {'Addr': '10.0.0.158:2377', 'NodeID': '71izy0goik036k48jg985xnds'},
                {'Addr': '10.0.0.159:2377', 'NodeID': '79y6h1o4gv8n120drcprv5nmc'},
                {'Addr': '10.0.0.46:2377', 'NodeID': 'k67qz4598weg5unwwffg6z1m1'},
            ]
        ],
    )


class SystemInfo(BaseModel):
    Architecture: Optional[str] = Field(
        None,
        description='Hardware architecture of the host, as returned by the Go runtime\n(`GOARCH`).\n\nA full list of possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment).\n',
        examples=['x86_64'],
    )
    BridgeNfIp6tables: Optional[bool] = Field(
        None,
        description='Indicates if `bridge-nf-call-ip6tables` is available on the host.',
        examples=[True],
    )
    BridgeNfIptables: Optional[bool] = Field(
        None,
        description='Indicates if `bridge-nf-call-iptables` is available on the host.',
        examples=[True],
    )
    CPUSet: Optional[bool] = Field(
        None,
        description='Indicates if CPUsets (cpuset.cpus, cpuset.mems) are supported by the host.\n\nSee [cpuset(7)](https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt)\n',
        examples=[True],
    )
    CPUShares: Optional[bool] = Field(
        None,
        description='Indicates if CPU Shares limiting is supported by the host.',
        examples=[True],
    )
    CgroupDriver_1: Optional[CgroupDriver] = Field(
        'cgroupfs',
        alias='CgroupDriver',
        description='The driver to use for managing cgroups.\n',
        examples=['cgroupfs'],
    )
    ClusterAdvertise: Optional[str] = Field(
        None,
        description='The network endpoint that the Engine advertises for the purpose of\nnode discovery. ClusterAdvertise is a `host:port` combination on which\nthe daemon is reachable by other hosts.\n\n<p><br /></p>\n\n> **Note**: This field is only propagated when using standalone Swarm\n> mode, and overlay networking using an external k/v store. Overlay\n> networks with Swarm mode enabled use the built-in raft store, and\n> this field will be empty.\n',
        examples=['node5.corp.example.com:8000'],
    )
    ClusterStore: Optional[str] = Field(
        None,
        description='URL of the distributed storage backend.\n\n\nThe storage backend is used for multihost networking (to store\nnetwork and endpoint information) and by the node discovery mechanism.\n\n<p><br /></p>\n\n> **Note**: This field is only propagated when using standalone Swarm\n> mode, and overlay networking using an external k/v store. Overlay\n> networks with Swarm mode enabled use the built-in raft store, and\n> this field will be empty.\n',
        examples=['consul://consul.corp.example.com:8600/some/path'],
    )
    ContainerdCommit: Optional[Commit] = None
    Containers: Optional[int] = Field(
        None, description='Total number of containers on the host.', examples=[14]
    )
    ContainersPaused: Optional[int] = Field(
        None, description='Number of containers with status `"paused"`.\n', examples=[1]
    )
    ContainersRunning: Optional[int] = Field(
        None,
        description='Number of containers with status `"running"`.\n',
        examples=[3],
    )
    ContainersStopped: Optional[int] = Field(
        None,
        description='Number of containers with status `"stopped"`.\n',
        examples=[10],
    )
    CpuCfsPeriod: Optional[bool] = Field(
        None,
        description='Indicates if CPU CFS(Completely Fair Scheduler) period is supported by the host.',
        examples=[True],
    )
    CpuCfsQuota: Optional[bool] = Field(
        None,
        description='Indicates if CPU CFS(Completely Fair Scheduler) quota is supported by the host.',
        examples=[True],
    )
    Debug: Optional[bool] = Field(
        None,
        description='Indicates if the daemon is running in debug-mode / with debug-level logging enabled.',
        examples=[True],
    )
    DefaultRuntime: Optional[str] = Field(
        'runc',
        description='Name of the default OCI runtime that is used when starting containers.\n\nThe default can be overridden per-container at create time.\n',
        examples=['runc'],
    )
    DockerRootDir: Optional[str] = Field(
        None,
        description='Root directory of persistent Docker state.\n\nDefaults to `/var/lib/docker` on Linux, and `C:\\ProgramData\\docker`\non Windows.\n',
        examples=['/var/lib/docker'],
    )
    Driver: Optional[str] = Field(
        None, description='Name of the storage driver in use.', examples=['overlay2']
    )
    DriverStatus: Optional[List[List[str]]] = Field(
        None,
        description='Information specific to the storage driver, provided as\n"label" / "value" pairs.\n\nThis information is provided by the storage driver, and formatted\nin a way consistent with the output of `docker info` on the command\nline.\n\n<p><br /></p>\n\n> **Note**: The information returned in this field, including the\n> formatting of values and labels, should not be considered stable,\n> and may change without notice.\n',
        examples=[
            [
                ['Backing Filesystem', 'extfs'],
                ['Supports d_type', 'true'],
                ['Native Overlay Diff', 'true'],
            ]
        ],
    )
    ExperimentalBuild: Optional[bool] = Field(
        None,
        description='Indicates if experimental features are enabled on the daemon.\n',
        examples=[True],
    )
    GenericResources_1: Optional[GenericResources] = Field(
        None, alias='GenericResources'
    )
    HttpProxy: Optional[str] = Field(
        None,
        description='HTTP-proxy configured for the daemon. This value is obtained from the\n[`HTTP_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.\n\nContainers do not automatically inherit this configuration.\n',
        examples=['http://user:pass@proxy.corp.example.com:8080'],
    )
    HttpsProxy: Optional[str] = Field(
        None,
        description='HTTPS-proxy configured for the daemon. This value is obtained from the\n[`HTTPS_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.\n\nContainers do not automatically inherit this configuration.\n',
        examples=['https://user:pass@proxy.corp.example.com:4443'],
    )
    ID: Optional[str] = Field(
        None,
        description='Unique identifier of the daemon.\n\n<p><br /></p>\n\n> **Note**: The format of the ID itself is not part of the API, and\n> should not be considered stable.\n',
        examples=['7TRN:IPZB:QYBB:VPBQ:UMPP:KARE:6ZNR:XE6T:7EWV:PKF4:ZOJD:TPYS'],
    )
    IPv4Forwarding: Optional[bool] = Field(
        None, description='Indicates IPv4 forwarding is enabled.', examples=[True]
    )
    Images: Optional[int] = Field(
        None,
        description='Total number of images on the host.\n\nBoth _tagged_ and _untagged_ (dangling) images are counted.\n',
        examples=[508],
    )
    IndexServerAddress: Optional[str] = Field(
        'https://index.docker.io/v1/',
        description='Address / URL of the index server that is used for image search,\nand as a default for user authentication for Docker Hub and Docker Cloud.\n',
        examples=['https://index.docker.io/v1/'],
    )
    InitBinary: Optional[str] = Field(
        None,
        description="Name and, optional, path of the the `docker-init` binary.\n\nIf the path is omitted, the daemon searches the host's `$PATH` for the\nbinary and uses the first result.\n",
        examples=['docker-init'],
    )
    InitCommit: Optional[Commit] = None
    Isolation: Optional[Isolation1] = Field(
        'default',
        description='Represents the isolation technology to use as a default for containers.\nThe supported values are platform-specific.\n\nIf no isolation value is specified on daemon start, on Windows client,\nthe default is `hyperv`, and on Windows server, the default is `process`.\n\nThis option is currently not used on other platforms.\n',
    )
    KernelMemory: Optional[bool] = Field(
        None,
        description='Indicates if the host has kernel memory limit support enabled.',
        examples=[True],
    )
    KernelVersion: Optional[str] = Field(
        None,
        description='Kernel version of the host.\n\nOn Linux, this information obtained from `uname`. On Windows this\ninformation is queried from the <kbd>HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\</kbd>\nregistry value, for example _"10.0 14393 (14393.1198.amd64fre.rs1_release_sec.170427-1353)"_.\n',
        examples=['4.9.38-moby'],
    )
    Labels: Optional[List[str]] = Field(
        None,
        description='User-defined labels (key/value metadata) as set on the daemon.\n\n<p><br /></p>\n\n> **Note**: When part of a Swarm, nodes can both have _daemon_ labels,\n> set through the daemon configuration, and _node_ labels, set from a\n> manager node in the Swarm. Node labels are not included in this\n> field. Node labels can be retrieved using the `/nodes/(id)` endpoint\n> on a manager node in the Swarm.\n',
        examples=[['storage=ssd', 'production']],
    )
    LiveRestoreEnabled: Optional[bool] = Field(
        False,
        description='Indicates if live restore is enabled.\n\nIf enabled, containers are kept running when the daemon is shutdown\nor upon daemon start if running containers are detected.\n',
        examples=[False],
    )
    LoggingDriver: Optional[str] = Field(
        None, description='The logging driver to use as a default for new containers.\n'
    )
    MemTotal: Optional[int] = Field(
        None,
        description='Total amount of physical memory available on the host, in kilobytes (kB).\n',
        examples=[2095882240],
    )
    MemoryLimit: Optional[bool] = Field(
        None,
        description='Indicates if the host has memory limit support enabled.',
        examples=[True],
    )
    NCPU: Optional[int] = Field(
        None,
        description='The number of logical CPUs usable by the daemon.\n\nThe number of available CPUs is checked by querying the operating\nsystem when the daemon starts. Changes to operating system CPU\nallocation after the daemon is started are not reflected.\n',
        examples=[4],
    )
    NEventsListener: Optional[int] = Field(
        None, description='Number of event listeners subscribed.', examples=[30]
    )
    NFd: Optional[int] = Field(
        None,
        description='The total number of file Descriptors in use by the daemon process.\n\nThis information is only returned if debug-mode is enabled.\n',
        examples=[64],
    )
    NGoroutines: Optional[int] = Field(
        None,
        description='The  number of goroutines that currently exist.\n\nThis information is only returned if debug-mode is enabled.\n',
        examples=[174],
    )
    Name: Optional[str] = Field(
        None, description='Hostname of the host.', examples=['node5.corp.example.com']
    )
    NoProxy: Optional[str] = Field(
        None,
        description='Comma-separated list of domain extensions for which no proxy should be\nused. This value is obtained from the [`NO_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html)\nenvironment variable.\n\nContainers do not automatically inherit this configuration.\n',
        examples=['*.local, 169.254/16'],
    )
    OSType: Optional[str] = Field(
        None,
        description='Generic type of the operating system of the host, as returned by the\nGo runtime (`GOOS`).\n\nCurrently returned values are "linux" and "windows". A full list of\npossible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment).\n',
        examples=['linux'],
    )
    OomKillDisable: Optional[bool] = Field(
        None, description='Indicates if OOM killer disable is supported on the host.'
    )
    OperatingSystem: Optional[str] = Field(
        None,
        description='Name of the host\'s operating system, for example: "Ubuntu 16.04.2 LTS"\nor "Windows Server 2016 Datacenter"\n',
        examples=['Alpine Linux v3.5'],
    )
    Plugins: Optional[PluginsInfo] = None
    RegistryConfig: Optional[RegistryServiceConfig] = None
    RuncCommit: Optional[Commit] = None
    Runtimes: Optional[Dict[str, Runtime]] = Field(
        default_factory=lambda: Runtime.model_validate(
            {'runc': {'path': 'docker-runc'}}
        ),
        description='List of [OCI compliant](https://github.com/opencontainers/runtime-spec)\nruntimes configured on the daemon. Keys hold the "name" used to\nreference the runtime.\n\nThe Docker daemon relies on an OCI compliant runtime (invoked via the\n`containerd` daemon) as its interface to the Linux kernel namespaces,\ncgroups, and SELinux.\n\nThe default runtime is `runc`, and automatically configured. Additional\nruntimes can be configured by the user and will be listed here.\n',
        examples=[
            {
                'custom': {
                    'path': '/usr/local/bin/my-oci-runtime',
                    'runtimeArgs': ['--debug', '--systemd-cgroup=false'],
                },
                'runc': {'path': 'docker-runc'},
                'runc-master': {'path': '/go/bin/runc'},
            }
        ],
    )
    SecurityOptions: Optional[List[str]] = Field(
        None,
        description='List of security features that are enabled on the daemon, such as\napparmor, seccomp, SELinux, and user-namespaces (userns).\n\nAdditional configuration options for each security feature may\nbe present, and are included as a comma-separated list of key/value\npairs.\n',
        examples=[
            [
                'name=apparmor',
                'name=seccomp,profile=default',
                'name=selinux',
                'name=userns',
            ]
        ],
    )
    ServerVersion: Optional[str] = Field(
        None,
        description='Version string of the daemon.\n\n> **Note**: the [standalone Swarm API](https://docs.docker.com/swarm/swarm-api/)\n> returns the Swarm version instead of the daemon  version, for example\n> `swarm/1.2.8`.\n',
        examples=['17.06.0-ce'],
    )
    SwapLimit: Optional[bool] = Field(
        None,
        description='Indicates if the host has memory swap limit support enabled.',
        examples=[True],
    )
    Swarm: Optional[SwarmInfo] = None
    SystemStatus: Optional[List[List[str]]] = Field(
        None,
        description='Status information about this node (standalone Swarm API).\n\n<p><br /></p>\n\n> **Note**: The information returned in this field is only propagated\n> by the Swarm standalone API, and is empty (`null`) when using\n> built-in swarm mode.\n',
        examples=[
            [
                ['Role', 'primary'],
                ['State', 'Healthy'],
                ['Strategy', 'spread'],
                [
                    'Filters',
                    'health, port, containerslots, dependency, affinity, constraint, whitelist',
                ],
                ['Nodes', '2'],
                [' swarm-agent-00', '192.168.99.102:2376'],
                [
                    '   ID',
                    '5CT6:FBGO:RVGO:CZL4:PB2K:WCYN:2JSV:KSHH:GGFW:QOPG:6J5Q:IOZ2|192.168.99.102:2376',
                ],
                ['   Status', 'Healthy'],
                ['   Containers', '1 (1 Running, 0 Paused, 0 Stopped)'],
                ['   Reserved CPUs', '0 / 1'],
                ['   Reserved Memory', '0 B / 1.021 GiB'],
                [
                    '   Labels',
                    'kernelversion=4.4.74-boot2docker, operatingsystem=Boot2Docker 17.06.0-ce (TCL 7.2); HEAD : 0672754 - Thu Jun 29 00:06:31 UTC 2017, ostype=linux, provider=virtualbox, storagedriver=aufs',
                ],
                ['   UpdatedAt', '2017-08-09T10:03:46Z'],
                ['   ServerVersion', '17.06.0-ce'],
                [' swarm-manager', '192.168.99.101:2376'],
                [
                    '   ID',
                    'TAMD:7LL3:SEF7:LW2W:4Q2X:WVFH:RTXX:JSYS:XY2P:JEHL:ZMJK:JGIW|192.168.99.101:2376',
                ],
                ['   Status', 'Healthy'],
                ['   Containers', '2 (2 Running, 0 Paused, 0 Stopped)'],
                ['   Reserved CPUs', '0 / 1'],
                ['   Reserved Memory', '0 B / 1.021 GiB'],
                [
                    '   Labels',
                    'kernelversion=4.4.74-boot2docker, operatingsystem=Boot2Docker 17.06.0-ce (TCL 7.2); HEAD : 0672754 - Thu Jun 29 00:06:31 UTC 2017, ostype=linux, provider=virtualbox, storagedriver=aufs',
                ],
                ['   UpdatedAt', '2017-08-09T10:04:11Z'],
                ['   ServerVersion', '17.06.0-ce'],
            ]
        ],
    )
    SystemTime: Optional[str] = Field(
        None,
        description='Current system-time in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt)\nformat with nano-seconds.\n',
        examples=['2017-08-08T20:28:29.06202363Z'],
    )


class Status(BaseModel):
    ContainerStatus_1: Optional[ContainerStatus] = Field(None, alias='ContainerStatus')
    Err: Optional[str] = None
    Message: Optional[str] = None
    State: Optional[TaskState] = None
    Timestamp: Optional[str] = None


class Task(BaseModel):
    AssignedGenericResources: Optional[GenericResources] = None
    CreatedAt: Optional[str] = None
    DesiredState: Optional[TaskState] = None
    ID: Optional[str] = Field(None, description='The ID of the task.')
    Labels: Optional[Dict[str, str]] = Field(
        None, description='User-defined key/value metadata.'
    )
    Name: Optional[str] = Field(None, description='Name of the task.')
    NodeID: Optional[str] = Field(
        None, description='The ID of the node that this task is on.'
    )
    ServiceID: Optional[str] = Field(
        None, description='The ID of the service this task is part of.'
    )
    Slot: Optional[int] = None
    Spec: Optional[TaskSpec] = None
    Status_1: Optional[Status] = Field(None, alias='Status')
    UpdatedAt: Optional[str] = None
    Version: Optional[ObjectVersion] = None


class ConfigsGetResponse(RootModel[List[Config]]):
    root: List[Config] = Field(
        ...,
        examples=[
            [
                {
                    'CreatedAt': '2016-11-05T01:20:17.327670065Z',
                    'ID': 'ktnbjxoalbkvbvedmg1urrz8h',
                    'Spec': {'Name': 'server.conf'},
                    'UpdatedAt': '2016-11-05T01:20:17.327670065Z',
                    'Version': {'Index': 11},
                }
            ]
        ],
    )


class ContainersIdUpdatePostRequest(Resources):
    RestartPolicy_1: Optional[RestartPolicy] = Field(None, alias='RestartPolicy')


class NetworksGetResponse(RootModel[List[Network]]):
    root: List[Network]


class PluginsGetResponse(RootModel[List[Plugin1]]):
    root: List[Plugin1]


class SecretsGetResponse(RootModel[List[Secret]]):
    root: List[Secret] = Field(
        ...,
        examples=[
            [
                {
                    'CreatedAt': '2017-07-20T13:55:28.678958722Z',
                    'ID': 'blt1owaxmitz71s9v5zh81zun',
                    'Spec': {
                        'Driver': {
                            'Name': 'secret-bucket',
                            'Options': {
                                'OptionA': 'value for driver option A',
                                'OptionB': 'value for driver option B',
                            },
                        },
                        'Labels': {'some.label': 'some.value'},
                        'Name': 'mysql-passwd',
                    },
                    'UpdatedAt': '2017-07-20T13:55:28.678958722Z',
                    'Version': {'Index': 85},
                },
                {
                    'CreatedAt': '2016-11-05T01:20:17.327670065Z',
                    'ID': 'ktnbjxoalbkvbvedmg1urrz8h',
                    'Spec': {'Labels': {'foo': 'bar'}, 'Name': 'app-dev.crt'},
                    'UpdatedAt': '2016-11-05T01:20:17.327670065Z',
                    'Version': {'Index': 11},
                },
            ]
        ],
    )


ServicesCreatePostRequest = ServiceSpec


ServicesIdUpdatePostRequest = ServiceSpec


class SystemDfGetResponse(BaseModel):
    Containers: Optional[List[ContainerSummary]] = None
    Images: Optional[List[ImageSummary]] = None
    LayersSize: Optional[int] = None
    Volumes: Optional[List[Volume]] = None


class TasksGetResponse(RootModel[List[Task]]):
    root: List[Task] = Field(
        ...,
        examples=[
            [
                {
                    'CreatedAt': '2016-06-07T21:07:31.171892745Z',
                    'DesiredState': 'running',
                    'ID': '0kzzo1i0y4jz6027t0k7aezc7',
                    'NetworksAttachments': [
                        {
                            'Addresses': ['10.255.0.10/16'],
                            'Network': {
                                'CreatedAt': '2016-06-07T20:31:11.912919752Z',
                                'DriverState': {
                                    'Name': 'overlay',
                                    'Options': {
                                        'com.docker.network.driver.overlay.vxlanid_list': '256'
                                    },
                                },
                                'ID': '4qvuz4ko70xaltuqbt8956gd1',
                                'IPAMOptions': {
                                    'Configs': [
                                        {
                                            'Gateway': '10.255.0.1',
                                            'Subnet': '10.255.0.0/16',
                                        }
                                    ],
                                    'Driver': {'Name': 'default'},
                                },
                                'Spec': {
                                    'DriverConfiguration': {},
                                    'IPAMOptions': {
                                        'Configs': [
                                            {
                                                'Gateway': '10.255.0.1',
                                                'Subnet': '10.255.0.0/16',
                                            }
                                        ],
                                        'Driver': {},
                                    },
                                    'Labels': {'com.docker.swarm.internal': 'true'},
                                    'Name': 'ingress',
                                },
                                'UpdatedAt': '2016-06-07T21:07:29.955277358Z',
                                'Version': {'Index': 18},
                            },
                        }
                    ],
                    'NodeID': '60gvrl6tm78dmak4yl7srz94v',
                    'ServiceID': '9mnpnzenvg8p8tdbtq4wvbkcz',
                    'Slot': 1,
                    'Spec': {
                        'ContainerSpec': {'Image': 'redis'},
                        'Placement': {},
                        'Resources': {'Limits': {}, 'Reservations': {}},
                        'RestartPolicy': {'Condition': 'any', 'MaxAttempts': 0},
                    },
                    'Status': {
                        'ContainerStatus': {
                            'ContainerID': 'e5d62702a1b48d01c3e02ca1e0212a250801fa8d67caca0b6f35919ebc12f035',
                            'PID': 677,
                        },
                        'Message': 'started',
                        'State': 'running',
                        'Timestamp': '2016-06-07T21:07:31.290032978Z',
                    },
                    'UpdatedAt': '2016-06-07T21:07:31.376370513Z',
                    'Version': {'Index': 71},
                },
                {
                    'CreatedAt': '2016-06-07T21:07:30.019104782Z',
                    'DesiredState': 'shutdown',
                    'ID': '1yljwbmlr8er2waf8orvqpwms',
                    'Name': 'hopeful_cori',
                    'NetworksAttachments': [
                        {
                            'Addresses': ['10.255.0.5/16'],
                            'Network': {
                                'CreatedAt': '2016-06-07T20:31:11.912919752Z',
                                'DriverState': {
                                    'Name': 'overlay',
                                    'Options': {
                                        'com.docker.network.driver.overlay.vxlanid_list': '256'
                                    },
                                },
                                'ID': '4qvuz4ko70xaltuqbt8956gd1',
                                'IPAMOptions': {
                                    'Configs': [
                                        {
                                            'Gateway': '10.255.0.1',
                                            'Subnet': '10.255.0.0/16',
                                        }
                                    ],
                                    'Driver': {'Name': 'default'},
                                },
                                'Spec': {
                                    'DriverConfiguration': {},
                                    'IPAMOptions': {
                                        'Configs': [
                                            {
                                                'Gateway': '10.255.0.1',
                                                'Subnet': '10.255.0.0/16',
                                            }
                                        ],
                                        'Driver': {},
                                    },
                                    'Labels': {'com.docker.swarm.internal': 'true'},
                                    'Name': 'ingress',
                                },
                                'UpdatedAt': '2016-06-07T21:07:29.955277358Z',
                                'Version': {'Index': 18},
                            },
                        }
                    ],
                    'NodeID': '60gvrl6tm78dmak4yl7srz94v',
                    'ServiceID': '9mnpnzenvg8p8tdbtq4wvbkcz',
                    'Slot': 1,
                    'Spec': {
                        'ContainerSpec': {'Image': 'redis'},
                        'Placement': {},
                        'Resources': {'Limits': {}, 'Reservations': {}},
                        'RestartPolicy': {'Condition': 'any', 'MaxAttempts': 0},
                    },
                    'Status': {
                        'ContainerStatus': {
                            'ContainerID': '1cf8d63d18e79668b0004a4be4c6ee58cddfad2dae29506d8781581d0688a213'
                        },
                        'Message': 'shutdown',
                        'State': 'shutdown',
                        'Timestamp': '2016-06-07T21:07:30.202183143Z',
                    },
                    'UpdatedAt': '2016-06-07T21:07:30.231958098Z',
                    'Version': {'Index': 30},
                },
            ]
        ],
    )


class HostConfig1(Resources):
    AutoRemove: Optional[bool] = Field(
        None,
        description="Automatically remove the container when the container's process exits. This has no effect if `RestartPolicy` is set.",
    )
    Binds: Optional[List[str]] = Field(
        None,
        description='A list of volume bindings for this container. Each volume binding is a string in one of these forms:\n\n- `host-src:container-dest` to bind-mount a host path into the container. Both `host-src`, and `container-dest` must be an _absolute_ path.\n- `host-src:container-dest:ro` to make the bind mount read-only inside the container. Both `host-src`, and `container-dest` must be an _absolute_ path.\n- `volume-name:container-dest` to bind-mount a volume managed by a volume driver into the container. `container-dest` must be an _absolute_ path.\n- `volume-name:container-dest:ro` to mount the volume read-only inside the container.  `container-dest` must be an _absolute_ path.\n',
    )
    CapAdd: Optional[List[str]] = Field(
        None, description='A list of kernel capabilities to add to the container.'
    )
    CapDrop: Optional[List[str]] = Field(
        None, description='A list of kernel capabilities to drop from the container.'
    )
    Cgroup: Optional[str] = Field(None, description='Cgroup to use for the container.')
    ConsoleSize: Optional[List[ConsoleSizeItem]] = Field(
        None,
        description='Initial console size, as an `[height, width]` array. (Windows only)',
        max_length=2,
        min_length=2,
    )
    ContainerIDFile: Optional[str] = Field(
        None, description='Path to a file where the container ID is written'
    )
    Dns: Optional[List[str]] = Field(
        None, description='A list of DNS servers for the container to use.'
    )
    DnsOptions: Optional[List[str]] = Field(None, description='A list of DNS options.')
    DnsSearch: Optional[List[str]] = Field(
        None, description='A list of DNS search domains.'
    )
    ExtraHosts: Optional[List[str]] = Field(
        None,
        description='A list of hostnames/IP mappings to add to the container\'s `/etc/hosts` file. Specified in the form `["hostname:IP"]`.\n',
    )
    GroupAdd: Optional[List[str]] = Field(
        None,
        description='A list of additional groups that the container process will run as.',
    )
    IpcMode: Optional[str] = Field(
        None,
        description='IPC sharing mode for the container. Possible values are:\n\n- `"none"`: own private IPC namespace, with /dev/shm not mounted\n- `"private"`: own private IPC namespace\n- `"shareable"`: own private IPC namespace, with a possibility to share it with other containers\n- `"container:<name|id>"`: join another (shareable) container\'s IPC namespace\n- `"host"`: use the host system\'s IPC namespace\n\nIf not specified, daemon default is used, which can either be `"private"`\nor `"shareable"`, depending on daemon version and configuration.\n',
    )
    Isolation_1: Optional[Isolation] = Field(
        None,
        alias='Isolation',
        description='Isolation technology of the container. (Windows only)',
    )
    Links: Optional[List[str]] = Field(
        None,
        description='A list of links for the container in the form `container_name:alias`.',
    )
    LogConfig_1: Optional[LogConfig] = Field(
        None,
        alias='LogConfig',
        description='The logging configuration for this container',
    )
    Mounts: Optional[List[Mount]] = Field(
        None, description='Specification for mounts to be added to the container.'
    )
    NetworkMode: Optional[str] = Field(
        None,
        description="Network mode to use for this container. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom network's name to which this container should connect to.",
    )
    OomScoreAdj: Optional[int] = Field(
        None,
        description='An integer value containing the score given to the container in order to tune OOM killer preferences.',
        examples=[500],
    )
    PidMode: Optional[str] = Field(
        None,
        description='Set the PID (Process) Namespace mode for the container. It can be either:\n\n- `"container:<name|id>"`: joins another container\'s PID namespace\n- `"host"`: use the host\'s PID namespace inside the container\n',
    )
    PortBindings_1: Optional[Dict[str, PortBindings]] = Field(
        None,
        alias='PortBindings',
        description='A map of exposed container ports and the host port they should map to.',
    )
    Privileged: Optional[bool] = Field(
        None, description='Gives the container full access to the host.'
    )
    PublishAllPorts: Optional[bool] = Field(
        None,
        description="Allocates a random host port for all of a container's exposed ports.",
    )
    ReadonlyRootfs: Optional[bool] = Field(
        None, description="Mount the container's root filesystem as read only."
    )
    RestartPolicy_1: Optional[RestartPolicy] = Field(None, alias='RestartPolicy')
    Runtime: Optional[str] = Field(
        None, description='Runtime to use with this container.'
    )
    SecurityOpt: Optional[List[str]] = Field(
        None,
        description='A list of string values to customize labels for MLS systems, such as SELinux.',
    )
    ShmSize: Optional[conint(ge=0)] = Field(
        None,
        description='Size of `/dev/shm` in bytes. If omitted, the system uses 64MB.',
    )
    StorageOpt: Optional[Dict[str, str]] = Field(
        None,
        description='Storage driver options for this container, in the form `{"size": "120G"}`.\n',
    )
    Sysctls: Optional[Dict[str, str]] = Field(
        None,
        description='A list of kernel parameters (sysctls) to set in the container. For example: `{"net.ipv4.ip_forward": "1"}`\n',
    )
    Tmpfs: Optional[Dict[str, str]] = Field(
        None,
        description='A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example: `{ "/run": "rw,noexec,nosuid,size=65536k" }`.\n',
    )
    UTSMode: Optional[str] = Field(
        None, description='UTS namespace to use for the container.'
    )
    UsernsMode: Optional[str] = Field(
        None,
        description='Sets the usernamespace mode for the container when usernamespace remapping option is enabled.',
    )
    VolumeDriver: Optional[str] = Field(
        None, description='Driver that this container uses to mount volumes.'
    )
    VolumesFrom: Optional[List[str]] = Field(
        None,
        description='A list of volumes to inherit from another container, specified in the form `<container name>[:<ro|rw>]`.',
    )


class Node(BaseModel):
    CreatedAt: Optional[str] = Field(
        None,
        description='Date and time at which the node was added to the swarm in\n[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.\n',
        examples=['2016-08-18T10:44:24.496525531Z'],
    )
    Description: Optional[NodeDescription] = None
    ID: Optional[str] = Field(None, examples=['24ifsmvkjbyhk'])
    ManagerStatus_1: Optional[ManagerStatus] = Field(None, alias='ManagerStatus')
    Spec: Optional[NodeSpec] = None
    Status: Optional[NodeStatus] = None
    UpdatedAt: Optional[str] = Field(
        None,
        description='Date and time at which the node was last updated in\n[RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.\n',
        examples=['2017-08-09T07:09:37.632105588Z'],
    )
    Version: Optional[ObjectVersion] = None


class Service(BaseModel):
    CreatedAt: Optional[str] = None
    Endpoint_1: Optional[Endpoint] = Field(None, alias='Endpoint')
    ID: Optional[str] = None
    Spec: Optional[ServiceSpec] = None
    UpdateStatus_1: Optional[UpdateStatus] = Field(
        None, alias='UpdateStatus', description='The status of a service update.'
    )
    UpdatedAt: Optional[str] = None
    Version: Optional[ObjectVersion] = None


class ContainersCreatePostRequest(ContainerConfig):
    HostConfig: Optional[HostConfig1] = None
    NetworkingConfig_1: Optional[NetworkingConfig] = Field(
        None,
        alias='NetworkingConfig',
        description="This container's networking configuration.",
    )


class ContainersCreatePostRequest1(ContainerConfig):
    HostConfig: Optional[HostConfig1] = None
    NetworkingConfig_1: Optional[NetworkingConfig] = Field(
        None,
        alias='NetworkingConfig',
        description="This container's networking configuration.",
    )


class ContainersIdJsonGetResponse(BaseModel):
    AppArmorProfile: Optional[str] = None
    Args: Optional[List[str]] = Field(
        None, description='The arguments to the command being run'
    )
    Config: Optional[ContainerConfig] = None
    Created: Optional[str] = Field(
        None, description='The time the container was created'
    )
    Driver: Optional[str] = None
    ExecIDs: Optional[str] = None
    GraphDriver: Optional[GraphDriverData] = None
    HostConfig: Optional[HostConfig1] = None
    HostnamePath: Optional[str] = None
    HostsPath: Optional[str] = None
    Id: Optional[str] = Field(None, description='The ID of the container')
    Image: Optional[str] = Field(None, description="The container's image")
    LogPath: Optional[str] = None
    MountLabel: Optional[str] = None
    Mounts: Optional[List[MountPoint]] = None
    Name: Optional[str] = None
    NetworkSettings: Optional[NetworkSettings1] = None
    Node: Optional[Dict[str, Any]] = Field(None, description='TODO')
    Path: Optional[str] = Field(None, description='The path to the command being run')
    ProcessLabel: Optional[str] = None
    ResolvConfPath: Optional[str] = None
    RestartCount: Optional[int] = None
    SizeRootFs: Optional[int] = Field(
        None, description='The total size of all the files in this container.'
    )
    SizeRw: Optional[int] = Field(
        None,
        description='The size of files that have been created or changed by this container.',
    )
    State: Optional[State1] = Field(None, description='The state of the container.')


class NodesGetResponse(RootModel[List[Node]]):
    root: List[Node]


class ServicesGetResponse(RootModel[List[Service]]):
    root: List[Service]
